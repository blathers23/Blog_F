# CS:APP

<!--more-->

## Chapter 1

1. clang中stdio.h的主要内容？include的作用?
2. AVX512指令集到底是什么？为什么不同的指令集可以影响程序执行的速度？
3. 什么是操作系统内核(kernel)？
4. 解释性语言和编译性语言之间有什么主要区别？

## Chapter 2

1. 汇编语言、机器语言。
   - 汇编语言是一种低级语言，文本。
   - 机器语言无需翻译计算机即可理解，二进制。

2. 计算机的字长？

   计算机的字长（word size）取决于***数据总线***的宽度，***指明指针数据的标称大小（nominal size）***，限制了虚拟地址的范围。对于总线长度为$w$的计算机，其虚拟地址的范围为$2^w - 1$。

3. C数据类型的典型大小（以字节为单位）。

   | 有符号  |     无符号     | 32位 | 64位 |
   | :-----: | :------------: | :--: | :--: |
   |  char   | unsigned char  |  1   |  1   |
   |  short  | unsigned short |  2   |  2   |
   |   int   |  unsigned int  |  4   |  4   |
   |  long   | unsigned long  |  4   |  8   |
   | int32_t |    uint32_t    |  4   |  4   |
   | int64_t |    uint64_t    |  8   |  8   |
   | char *  |                |  4   |  8   |
   |  float  |                |  4   |  4   |
   | double  |                |  8   |  8   |

   > int32_t和int64_t的出现是为了防止不同编译系统编译相同声明出现数据大小不一的情况。

4. 声明指针。

   对于任何数据类型T，声明T *p，表明p是一个指针对象，指向一个类型为T的对象。

5. 字节存储顺序。

   最低有效位字节在最前面的方式，称为小端法（little endian）；最高有效位字节在最前面的方式，称为大端法（big endian）。比较新的微处理器使用双端法（bi-endian），可以把机器配置为大端或者小端来运行。一旦选择了操作系统，字节顺序随之固定。

6. 为什么相同的程序在不同机器或系统上编译得到的二进制代码不同？既然不同，那为什么exe文件，deb文件，他们的工作原理又是什么？

7. 异或逆元（a^a = 0）:

   ```c
   void inplace_swap(int *x, int *y) {
       *y = *x ^ *y;
       *x = *x ^ *y;
       *y = *x ^ *y;
   }
   ```

8. 移位运算。

   C语言中移位运算不会修改总位数。对于有符号数，几乎所有的编译器/机器的组合都使用算术右移（考虑正负号），对于无符号数，必须使用逻辑右移。

   C语言中移位运算符的优先级小于加减法。

9. 整数隐式转换。

   当执行一个运算时，假设同时存在有符号数和无符号数，那么C会转换有符号数为无符号数，并且假设所有的数都是非负的。*当把short转换为unsigned时，先转换长度，后转换符号，这是C语言标准所要求的。*

**第二章至2.3.2，过于无聊暂且跳过。**

## Chapter 3

1. 链接器的任务之一就是为函数调用找到匹配函数的可执行代码的位置（地址）。

2. x86-64的CPU包含一组16个存储64位值的通用目的寄存器，用于存放整数数据和指针。

3. 操作数值。

   最常用的寻址模式为比例变址寻址：$Imm(r_b, r_i, s) = M[Imm + R[r_b] + R[r_i] \cdot s]$。

4. 程序栈栈顶为小地址，栈底为大地址。

5. 


---

> 作者: Blathers  
> https://blathers23.netfily.app/csapp/
