# CS:APP

<!--more-->

## Chapter 1

1. clang中stdio.h的主要内容？include的作用?
2. AVX512指令集到底是什么？为什么不同的指令集可以影响程序执行的速度？
3. 什么是操作系统内核(kernel)？
4. 解释性语言和编译性语言之间有什么主要区别？

## Chapter 2

1. 汇编语言、机器语言。
   - 汇编语言是一种低级语言，文本。
   - 机器语言无需翻译计算机即可理解，二进制。

2. 计算机的字长？

   计算机的字长（word size）取决于***数据总线***的宽度，***指明指针数据的标称大小（nominal size）***，限制了虚拟地址的范围。对于总线长度为$w$的计算机，其虚拟地址的范围为$2^w - 1$。

3. C数据类型的典型大小（以字节为单位）。

   | 有符号  |     无符号     | 32位 | 64位 |
   | :-----: | :------------: | :--: | :--: |
   |  char   | unsigned char  |  1   |  1   |
   |  short  | unsigned short |  2   |  2   |
   |   int   |  unsigned int  |  4   |  4   |
   |  long   | unsigned long  |  4   |  8   |
   | int32_t |    uint32_t    |  4   |  4   |
   | int64_t |    uint64_t    |  8   |  8   |
   | char *  |                |  4   |  8   |
   |  float  |                |  4   |  4   |
   | double  |                |  8   |  8   |

   > int32_t和int64_t的出现是为了防止不同编译系统编译相同声明出现数据大小不一的情况。

4. 声明指针。

   对于任何数据类型T，声明T *p，表明p是一个指针对象，指向一个类型为T的对象。

5. 字节存储顺序。

   最低有效位字节在最前面的方式，称为小端法（little endian）；最高有效位字节在最前面的方式，称为大端法（big endian）。比较新的微处理器使用双端法（bi-endian），可以把机器配置为大端或者小端来运行。一旦选择了操作系统，字节顺序随之固定。

6. 为什么相同的程序在不同机器或系统上编译得到的二进制代码不同？既然不同，那为什么exe文件，deb文件，他们的工作原理又是什么？

7. 异或逆元（a^a = 0）:

   ```c
   void inplace_swap(int *x, int *y) {
       *y = *x ^ *y;
       *x = *x ^ *y;
       *y = *x ^ *y;
   }
   ```

8. 移位运算。

   C语言中移位运算不会修改总位数。对于有符号数，几乎所有的编译器/机器的组合都使用算术右移（考虑正负号），对于无符号数，必须使用逻辑右移。

   C语言中移位运算符的优先级小于加减法。

9. 整数隐式转换。

   当执行一个运算时，假设同时存在有符号数和无符号数，那么C会转换有符号数为无符号数，并且假设所有的数都是非负的。*当把short转换为unsigned时，先转换长度，后转换符号，这是C语言标准所要求的。*

**第二章至2.3.2，暂且跳过。**

## Chapter 3

1. 链接器的任务之一就是为函数调用找到匹配函数的可执行代码的位置（地址）。

2. x86-64的CPU包含一组16个存储64位值的通用目的寄存器，用于存放整数数据和指针。

3. 操作数值。

   最常用的寻址模式为比例变址寻址：$Imm(r_b, r_i, s) = M[Imm + R[r_b] + R[r_i] \cdot s]$。

   其他的寻址模式均为该寻址模式的特殊形式。

4. 程序栈栈顶为小地址，栈底为大地址。

5. 条件码寄存器，单个位（1bit），由CPU维护，描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。

   - CF：进位标志
   - ZF：零标志
   - SF：符号标志 —— 最近的操作得到的结果为负数。
   - OF：溢出标志 —— 最近的操作导致补码正负溢出。

6. PC中保存的为下一条指令的地址。

7. 实现条件操作的传统方式为通过使用**控制**的**条件跳转**。当条件满足时，程序沿着一条执行路径执行，当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。（分支预测逻辑）

8. 另一种实现条件策略的方式是使用**数据**的**条件传送**。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足选择其中一个。（无需进行分支预测）

9. 不是所有的条件表达式都可以使用条件传送来编译。

10. C语言指针运算。

    int E[some number]

    |    表达式    | 类型  |         值         |
    | :----------: | :---: | :----------------: |
    |      E       | int * |       $x_E$        |
    |     E[0]     |  int  |      M[$x_E$]      |
    |     E[i]     |  int  |    M[$x_E$ + 4]    |
    |    &E[2]     | int * |     $x_E$ + 8      |
    |  E + i  - 1  | int * |   $x_E$ + 4i - 4   |
    | *(E + i - 3) |  int  | M[$x_E$ + 4i - 12] |
    |  &E[i] - E   | long  |         i          |

    可以看到C有一个神奇的特性，就是当两个指针相减时，得到的数据类型为long，值为两地址差除以指针所指数据类型长度。

    ```bash
    touch test.c	# 新建test.c
    nano test.c		# 使用nano编辑test.c
    ```

    ```C
    #include <stdio.h>
    
    void main() {
    	int e[10];
    	int i = 2;
    	printf("e: %p\n", e);
    	printf("&e[%d]: %p\n", i, &e[i]);
    	printf("&e[%d] - e: %ld\n", i, &e[i] - e);	// 相减得到数据类型为long，使用%ld输出。如果使用%p编译器会报错。
    }
    ```

    ```bash
    gcc -o test.out test.c	# gcc编译
    ./test.out				# 查看输出
    # 输出
    > e: 0x7fffef9ea770
    > &e[2]: 0x7fffef9ea778
    > &e[2] - e: 2
    ```

    可以看到差并不相等。

11. 数组的嵌套。

    ```C
    int A[5][3];
    
    typedef int row3_t[3];	// 上下两种定义方式等价
    row3_t A[5];
    ```

12. 异质的数据结构。

    C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构（structure），用关键字struct声明，将多个对象集合到一个单位中；联合（union），用关键字union声明，允许用几种不同的类型来引用一个对象。

13. 


---

> 作者: Blathers  
> https://blathers23.netfily.app/csapp/
