[{"categories":null,"content":"Blathers' friends","date":"2022-05-01","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"基本资讯 - nickname:Blathersavatar:https://gravatar.loli.net/avatar/1cc24367e7133aceb81bfd9ef41481cd?s=240\u0026d=mpurl:https://blathers233.netlify.appdescription:Blathers Tent ","date":"2022-05-01","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"友情提示 提示 If you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only) Warn: Website failure, stop maintenance and improper content may be cancelled! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2022-05-01","objectID":"/friends/:2:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":["教程"],"content":"本文旨在提供使用 Hugo + GitHub Pages or Netlify + Waline + PicGo 搭建个人博客的轻松无脑一站式体验教程。","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":" 轻松拿下 Hugo，因为我站在大佬的肩膀上。  提示 如有问题欢迎与我联系😀。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:0:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"0. 安装 Hugo Hugo 可以选择二进制安装或者自行下载源码编译安装。此处选择轻松简单快捷的二进制安装。进入 Hugo Releases，根据你的操作系统选择相应的版本。在此处我推荐安装 Hugo_extended 版本。该版本可以允许你更加轻松的修改主题。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:1:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"1. 生成站点 以 Windows 系统为例，下载二进制程序后，在程序所在文件夹打开 PowerShell，运行： .\\hugo new site .\\your_stie_name 即可在 .\\your_site_name 路径下生成你的站点文件夹。现在： cd .\\your_site_name ..\\hugo new about.md 就可以看到 about.md 自动生成到了 \\your_stie_name\\content 文件夹下。请注意，当前你的 PowerShell 的路径应当在 \\your_stie_name，这意味着 Hugo 将为该站点生成 about.md。事实上，你可以通过 Hugo 生成并管理多个站点。 提示 你也可以不通过 hugo new 而是手动新建 .md 文件在 \\content 文件夹下。你所有的页面都将由该文件夹下的 .md 文件生成。 现在打开 about.md，你将看到： ---title:\"About\"date:2022-04-19T21:43:04+08:00---正文内容 夹在两排 --- 之间的内容是对将要生成的页面的描述，包含了标题，日期等内容。现在创建第一篇文章，放到 posts 目录，方便之后生成聚合页面： ..\\hugo new posts\\first.md 打开并编辑 first.md： ---date:\"2022-04-19T23:33:33+08:00\"title:\"first\"---# Hello Hugo1. aaa2. bbb3. ccc 就可以对你将要发布的页面进行编辑。此时你可能正在寻找一款好用的 Markdown 编辑器， Typora 是很棒的选择。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:2:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"2. 挑选主题 在正式发布你的页面之前，你还需要为页面挑选一款耐看的主题。进入 Hugo themes 网页挑选主题并下载后，将其解压到 \\your_stie_name\\themes 文件夹下，例如我下载了 Diary 主题，那么我的文件夹布局为：\\your_stie_name\\themes\\diary。请注意，你可以将主题的文件夹修改成一个好记的名字，以后将多次键入这个文件夹的名字。 注意 不同的主题在一些细节上可能有所不同，当然这是日后的课题。对于不同的主题，你可以查询该主题的文档来获得更多的支持。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:3:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"3. 测试你的页面 在挑选并下载主题之后，你可以在本地运行你的博客并查看效果。在 \\your_site_name 打开 PowerShell，运行： ..\\hugo --theme=your_theme_name server 你就可以在 http://localhost:1313/ 预览网页的效果。值得一提的是，如果你此时对 about.md 或者 config.toml （稍后会讲到）等进行修改并保存，这些改动将会实时的反映在你的网页上。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:4:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"4. 发布你的页面 当你对页面改动满意后，你可以将你的页面发布到 GitHub 上以便使用 GitHub Pages 来托管你的网页。首先在 GitHub 上为你的 Blog 新建一个仓库，然后在 your_site_name 文件夹下运行： ..\\hugo --theme=your_theme_name 运行结束后，你的页面将会被保存到 \\your_site_name\\public 文件下，接下来你可以将该文件夹上传到仓库，运行： cd .\\public\\ git init git remote add origin https://github.com/your_user_name/your_repo_name.git git add . git commit -m 'first commit' git push -u origin master ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:5:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"5. GitHub Pages or Netlify 进入你的仓库，选择 settings - pages，Source 选择 master，folder 选择 \\(root)，然后点击 save。一段时间后，你的 GitHub Pages 就可以成功访问了。这里建议将仓库命名为 your_user_name.github.io，这样的话，你的主页网址将为：https:\\\\your_user_name.github.io 。对于一般仓库名，你的主页网址将为：https:\\\\your_user_name.github.io\\your_repo_name。 除了 GitHub Pages 外，你也可以选择其他的静态页面托管服务。这里简短介绍 Netlify。只需要通过 GitHub 登录 Netlify，你就可以直接将仓库中的网页部署在 Netlify 中，并且支持自定义域名和自动部署等便利的功能。 访问你的页面，你可能会发现一些问题，例如点击页面链接后跳转失败等。这些问题需要通过一些设置来解决。👇 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:6:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"6. config.toml 该文件位于 \\your_site_name 文件夹下，页面的大多数设置都可以在此处调整。首先应当调整 baseURL 项为你的主页网址。这样就可以使链接跳转正常。 除此之外，页面的其他设置也可以在此处调整。例如页面的边栏 sidebar，你可以在 config.toml 文件中添加: [[menu.main]] url = \"/posts\" name = \"Archive\" weight = 1 [[menu.main]] url = \"/tags\" name = \"Tags\" weight = 2 [[menu.main]] url = \"/categories\" name = \"Categories\" weight = 3 [[menu.main]] url = \"/about\" name = \"About\" weight = 4 就可以将页面调整的边栏调整为4个选项，分别是 Archive、Tags、Categories 和 About。对于 \\about ，在 \\content 文件夹内，该地址为一个 .md 文件，因此该边栏选项点击后将呈现 About 页面，也就是根据你在 about.md 中所键入内容生成的网页。对于 \\posts ，在 \\content 文件夹下，该地址为一个文件夹，因此该边栏选项点击后将呈现一个页面聚合。\\tags 和 \\categories 则是自动对标签和分类进行聚集生成的页面，有关标签和分类的内容将会在稍后讨论。 提示 有关 \\ 和 / 的差别，这是 Windows 和 Linux 的一个稍稍的不同。 另外一个例子是网页图标，你也可以在 config.toml 中进行控制，你可以输入： [params] favicon = \"your_image_path\" 来控制网页的图标位置。你需要将你的图片放入到 \\your_site_name\\static\\images 文件夹下。例如我将图片 QUIN.png 放置到该文件夹中，对于 GitHub Pages 的一般仓库名，我的 \"your_image_path\" 应当为 \"\\your_repo_name\\images\\QUIN.png\"，而对于 Netlify 和 GitHub Pages 的独有仓库名，我的\"your_image_path\" 应当为 \"\\images\\QUIN.png\"。 注意 尽管这种方式可以正确的加载网页图标和页面头图（稍后会讲到），但是这种方式并不能很好的支持页面内图片的内容，我不清楚这是什么原因。但是这种方式来放置页面内图片，不仅会导致本地编辑 .md 文件时不能正常预览图片，服务端有限的网速也会导致网页浏览体验下降，因此可以使用网络图床来解决这个问题。 提示 当然网页图标和页面头图也可以使用图床。 \r 当然，网页当中还有很多元素可以自定义，根据你使用的主题不同，又有一些额外的内容可以控制。对于额外的内容，你需要查询你选择的主题的文档，对于通用内容，你可以阅读 Hugo 文档来学习如何调整。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:7:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"7. 写作 完成上述设置后，推送你所完成的更改，可以看到网页已经可以正常使用了。接下来我们将要讨论的是写作中一些剩余的问题。在 .md 文件的开头，夹在两行 --- 之间的内容称为元数据（meta data）。这些元数据根据你所选主题的不同，可能会有些出入，请参考你所选择的主题其中的项目。这里以 Diary 主题为例，对一些元数据进行介绍： title:\"浅入浅出 Hugo 教程\"date:2022-04-24T16:33:00+08:00lastmod:\"2022-04-24\"description:\"轻松拿下 Hugo，因为我站在大佬的肩膀上。\"featured_image:\"\"tags:[Hugo, Blog]categories:教程comment:TrueenableLaTeX:False title：文章的标题 data：文章创建的时间 lastmod：文章最后修改的时间 featured_image：文章头图 tags：标签 categories：分类 comment：时候启用评论 enableLaTex：是否启用 LATEX 不同的主题可能有所出入，这里需要以你所用主题的文档为准。以主题 Diary 为例，当你为一篇文章添加 tags 和 categories 后，将会自动聚合内容生成 \\Tags 和 \\Categories 页面，尽管这两个文件夹并不在你 \\content 文件夹下。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:8:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"8. 评论区 评论区很多不同的选择，在这里介绍 Waline 评论系统。对于主题 Diary 来说，已经内置了 Waline 评论系统，只需要在 config.toml 中添加： [params] walineServer = \"your_waline_server\" 即可添加评论区。对于其它主题，你可能需要查询其文档来确定是否原生支持 Waline，若不支持且你被允许修改主题的内容，你可以参考 Waline 官方教程来引入 Waline 评论系统。 一旦你可以正确的引入客户端，你就可以设置 WalineServer。设置 WalineServer 的方式也在 Waline 官网提供了详细的教程。这里提醒一点，当完成 WalineServer 的设置后，一定不要忘记注册评论管理页面，首个在评论管理页面注册的用户将成为评论区管理员。 对于 Waline 的其它功能，例如自定义表情，自定义样式等，你可能需要在主题的 HTML 文件中进行修改。以主题 Diary 为例，你需要打开位于 your_site_name\\themes\\diary\\layouts\\partials 文件夹下的 comment.html 文件，对其中的内容进行修改。 以添加自定义表情为例，你需要对 comment.html 下 new Waline 中的内容进行修改。如要添加哔哩哔哩的表情，你需要将 new Waline 中的内容修改为： \u003cscript\u003e new Waline({ el: '#waline', path: location.pathname, serverURL: {{.Site.Params.walineServer}}, emoji: [ 'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili', ], }); \u003c/script\u003e 而以添加自定义样式为例，你则需要在 comment.html 中添加： \u003cstyle\u003e :root { /* 主题色 */ --waline-theme-color: #27ae60; --waline-active-color: #2ecc71; } \u003c/style\u003e 即可对主题色进行修改。更多内容，请参考 Waline 官方文档。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:9:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"⑨. 图床 优秀的图床可以大大提升网站浏览的体验，在这里推荐 PicGo 图片上传及管理工具。你可以在 PicGo releases 页面下载 PicGo。这里以 SM.MS 图床加 PicGo 简单介绍以下使用 PicGo 进行图片上传及管理的流程。 首先打开 SM.MS 官网，进行注册并登录后，点击 User - Dashboard，跳转页面后选择 API token，然后点击 Generate Secret Token 就可生成你的 token。 接下来打开 PicGo，选择 图床设置 - SM.MS图床，将上一步生成的 token 填入并点击确定，就完成了全部的设置。PicGo 同样支持很多其它图床，也包括自定义图床。其它内容请参考 PicGo 文档。 🙌 至此，本教程的全部内容已经施工完成。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:10:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["leetcode"],"content":"双指针真是太棒啦 -\u003e 二分查找也是","date":"2022-04-24","objectID":"/lc15/","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":" 问题链接：三数之和 ","date":"2022-04-24","objectID":"/lc15/:0:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"思考 从一个列表中选出所有和为零的三个数的组合，并且不重复，最简单的方式即为三重 for 循环，然后排除重复的组合。时间复杂度为 $\\mathcal{O}(n^3)$。 ","date":"2022-04-24","objectID":"/lc15/:1:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"代码 class Solution: def threeSum(self, nums: List[int]) -\u003e List[List[int]]: nums.sort() length = len(nums) if length \u003c 3: return [] res = [] for i in range(0, length - 2): for j in range(i + 1, length - 1): for k in range(j + 1, length): if nums[i] + nums[j] + nums[k] == 0: el = [nums[i], nums[j], nums[k]] if el not in res: res.append(el) return res 三重 for 循环很容易实现，但是问题是如何排除重复项。重复项的三个数可能以不同的顺序排列，这增加了查重的难度。这里的方法是对首先对数组进行排序，这样保证所有可能中的数大小有序，减少排除重复项的难度。 然后简简单单的 TLE。 最容易想到的下一步改进方式就是，如果我们固定住三个数中的一个数，那么问题就转变为了 LC1 两数之和。对于两数字和来说，最佳的解法为 hashmap，时间复杂度为 $\\mathcal{O}(n)$，考虑外循环，时间复杂度来到了 $\\mathcal{O}(n^2)$。 class Solution: def twoSum(self, nums, target): res = [] map = {} for i in range(len(nums)): need = target - nums[i] if need in map: res.append([nums[map[need]], nums[i]]) else: map[nums[i]] = i return res def threeSum(self, nums): nums.sort() length = len(nums) if length \u003c 3: return [] res = [] for i in range(0, length - 2): others = self.twoSum(nums[i + 1:], target=-nums[i]) if others != []: for other in others: ele = [nums[i]] + other if ele not in res: res.append(ele) return res 这里与 LC1 的一个很大的不同是，twoSum 函数有多个可能的返回结果。这要求我们一定要遍历完所有的可能，导致虽然时间复杂度为 $\\mathcal{O}(n^2)$，运行速度依旧很慢，勉强为通过的结果。 执行用时: 4824 ms，超过了 5% 的 Python 提交记录。 内存消耗: 17.8 MB，超过了 67% 的 Python 提交记录。 ","date":"2022-04-24","objectID":"/lc15/:2:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针解法 在上述代码中，另一个时间消耗大户为排查重复项。有 hashmap 不便分析，回到最初的三重循环的想法：可以注意到，只要三重循环中的每一重循环都跳过重复项，就可以不需要最后额外的排查重复项。如果最初进行一次数组的排序，那么我们只需要检查当前值和上一步的值是否相同，就可以跳过重复项。这是因为排序后所有值相同的数全部相邻。 然而这就为 hashmap 解法引入了新的问题。注意到 hashmap 仅有一根指针，我们不能轻易排除重复项，这是因为 $target$ 很有可能等于相同的两项之和。例如 $target = 0$，$nums = [0, 0]$，此时如果我们跳过相同的数，那么将不会得到正确的返回结果 $[0, 0]$。为了正确的返回结果，还必须引入一个为每个元素进行计数的计数器。 那么有没有什么方式可以在引入双指针的同时将 twoSum 的时间复杂度降为 $\\mathcal{O}(n)$ 呢？这里，我们注意到数组已经有序。参考 LC11 的思路，对于任意的双指针 $j$ 和 $k$，假设 $j \u003c k$ 。那么此时有三种情况： $nums[j] + nums[k] \u003c target$： 此时可以注意到，如果我们继续减小 $k$，直到$k = j + 1$，也不会遇到符合条件的结果。换句话说，对于当前 $j$ 而言，$k \\in [j+1, k]$ 不可能存在符合条件的结果。 $nums[j] + nums[k] \u003e target$： 此时可以注意到，如果我们继续增加 $j$，直到$j = k - 1$，也不会遇到符合条件的结果。换句话说，对于当前 $k$ 而言，$j \\in [j, k-1]$ 不可能存在符合条件的结果。 $nums[j] + nums[k] = target$： 此时符合条件，可以返回值。 因此我们可以得知，在区间 $[j, k]$ 内，对于情况 1，我们只需要继续搜索区间 $[j+1, k]$，而对于情况 2，我们也只需要继续搜索区间 $[j,k-1]$ 才可能会出现符合条件的结果。而对于情况 3，我们只需要继续搜索区间 $[j+1, k-1]$。无论怎样，经过一次计算，我们需要考虑的列表长度都会减少 1 或 2，这意味着 twoSum 的时间复杂度来到了 $\\mathcal{O}(n)$。 ","date":"2022-04-24","objectID":"/lc15/:3:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针代码 class Solution: def threeSum(self, nums: List[int]) -\u003e List[List[int]]: length = len(nums) nums.sort() res = [] for i in range(0, length - 2): if nums[i] \u003e 0: break if i \u003e 0 and nums[i] == nums[i - 1]: continue target = -nums[i] k = length - 1 j = i + 1 while k \u003e j: if nums[j] + nums[k] \u003e target: k -= 1 elif nums[j] + nums[k] \u003c target: j += 1 else: res.append([nums[i], nums[j], nums[k]]) k -= 1 j += 1 while k \u003e j and nums[k] == nums[k + 1]: k -= 1 while k \u003e j and nums[j] == nums[j - 1]: j += 1 return res 此处依旧有一些细节需要注意。对于 twoSum 部分，使用 while 循环来代替 for 循环可以极大的减少运行的时间，对于最外层循环，当 $nums[i] \u003e 0$ 时，无论 $j$ 和 $k$ 取何值，都无法得到 0，因此可以直接结束全部计算，这是因为数组已经经过了从大到小的排序。 总体来说，twoSum 部分时间复杂度为 $\\mathcal{O}(n)$，嵌套在外层循环中，整体时间复杂度为 $\\mathcal{O}(n^2)$，考虑到排序的时间复杂度为 $\\mathcal{O}(nlogn)$，因此整体时间复杂度依旧为 $\\mathcal{O}(n^2)$。与 hashmap 的解法相比，虽然时间复杂度相同，但是没有了排除重复项及 hashmap 的影响，最终结果得到了很好的提升。 执行用时: 436 ms，超过了 99% 的 Python 提交记录。 内存消耗: 17.8 MB，超过了 72% 的 Python 提交记录。 ","date":"2022-04-24","objectID":"/lc15/:4:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"最后 1% 注意到 $j$ 和 $k$ 的初值设置问题。由于列表有序，我们完全可以使用二分查找减少双指针最初无用的查找。Python 内置了 bisect 库，可以使用二分查找方便的生成列表中目标元素的索引。增加二分查找后，代码如下： # ······ k = length - 1 j = i + 1 if nums[j] + nums[k] \u003e target: k = bisect.bisect_right(nums, target - nums[j], j + 1, k) else: j = bisect.bisect_left(nums, target - nums[k], j, k - 1) # ······ 最终结果： 执行用时: 300 ms，超过了 100% 的 Python 提交记录。 内存消耗: 17.9 MB，超过了 53% 的 Python 提交记录。 同样的思路，双指针 + 二分查找可以用在 LC16 最接近的三数之和上。 问题链接：最接近的三数之和 附代码： class Solution: def threeSumClosest(self, nums: List[int], target: int) -\u003e int: res = 10 ** 4 sum = 0 need_ = 0 length = len(nums) if length == 3: return nums[0] + nums[1] + nums[2] nums.sort() for i in range(length - 2): need = target - nums[i] if i \u003e 0 and nums[i] == nums[i - 1]: continue if target \u003e 0 and need \u003c= 0: if abs(res - target) \u003e abs(nums[i] + nums[i + 1] + nums[i + 2] - target): res = nums[i] + nums[i + 1] + nums[i + 2] break j = i + 1 k = length - 1 if nums[j] + nums[k] \u003e need: k = bisect.bisect_right(nums, need - nums[j], i + 2, k) else: j = bisect.bisect_left(nums, need - nums[k], i + 1, k - 1) - 1 while j \u003c k: sum = nums[i] + nums[j] + nums[k] if abs(res - target) \u003e abs(sum - target): res = sum need_ = nums[j] + nums[k] if need_ \u003e need: k -= 1 while j \u003c k and nums[k] == nums[k + 1]: k -= 1 elif need_ \u003c need: j += 1 while j \u003c k and nums[j] == nums[j - 1]: j += 1 else: return target return res 执行用时: 32 ms，超过了 100% 的 Python 提交记录。 内存消耗: 15.2 MB，超过了 14% 的 Python 提交记录。 最后，100% 真好看。😎 ","date":"2022-04-24","objectID":"/lc15/:5:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针是好文明","date":"2022-04-20","objectID":"/lc11/","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":" 问题链接：盛水最多的容器 ","date":"2022-04-20","objectID":"/lc11/:0:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"思考 易得：面积公式为 $S = (r - l) \\times min(height[r], height[l])$，$r$ 和 $l$ 分别为所选择两条线的序号。最容易想到的解决方式即为双循环，遍历所有可能的 $r$ 和 $l$ 的组合。 ","date":"2022-04-20","objectID":"/lc11/:1:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"代码 class Solution: def maxArea(self, height: List[int]) -\u003e int: maxS = 0 for r in range(1, len(height)): for l in range(0, len(height)): maxS = max(maxS, (r - l) * min(height[r], height[l])) return maxS 简单双循环代码，没有什么可解释的。 然而对于一道中等难度的题来说，这种解法实在是有些不能令人满意。实际上这段代码运行后会超时，Time Limit Exceeded，喜闻乐见的 TLE。 当然，我不会这么简单就放弃（这么简单的算法还是早点放弃得了）。将语言换成 C 后，代码如下： int maxArea(int* height, int heightSize){ int maxS = 0; for (int r = 1; r \u003c heightSize; r++) { bool Higher = false; int Highest = height[0]; for (int l = 0; l \u003c heightSize; l++) { if (height[l] \u003c= height[r]) { if (height[l] \u003e= Highest) { maxS = fmax(maxS, (r - l) * fmin(height[l], height[r])); Highest = height[l]; } } else { if (!Higher) { maxS = fmax(maxS, (r - l) * fmin(height[l], height[r])); Higher = true; } } } } return maxS; } 代码优化。 相较于 Python 的代码，这里又进行了一些优化。注意到在内循环（也即 $l$ 循环）的过程中，$l$ 值不断变大，意味着公式中 $(r - l)$ 的部分会不断变小。这里分为两个情况： $height[l]$ 比 $height[r]$ 更低： 此时容器的盛水量由 $height[l]$ 决定而不是 $height[r]$ 。当 $(r - l)$ 不断变小，这意味着我们需要找到更大的 $height[l]$ 才有可能计算处更大的盛水量 $S$。因此在内循环过程中，记录所碰到的 $height[l]$ 的最大值，仅当当前 $height[l]$ 值比历史最大值大时，才进行盛水量的计算，否则直接跳过这次循环。 $height[l]$ 比 $height[r]$ 高： 此时容器的盛水量由 $height[r]$ 决定，在内循环过程中，当 $l$ 不断变大，即 $(r - l)$ 不断变小，盛水量 $S$ 必定为不断减少。因此当 $height[l] \u003e height[r]$ 时，一次内循环仅需要计算第一次的盛水量，因为第二次、第三次等以后次数的盛水量必定小于第一次的盛水量。 在这样的优化条件下，代码依旧碰上了喜闻乐见的 TLE。事实证明 $\\mathcal{O}(n^2)$ 的算法在这种拙劣的优化下没有什么用处，该 $\\mathcal{O}(n^2)$ 还是 $\\mathcal{O}(n^2)$。 ","date":"2022-04-20","objectID":"/lc11/:2:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"双指针解法 换个思路。双重循环实际上就是双指针，右指针每次向右移动一位，而左指针每次从开始位置移动到右指针所在位置。这带来一个问题，注意到 $S = (r - l) \\times min(height[r], height[l])$ ，在内循环过程中，第一项始终不断变小，而当外循环每移动一次，第一项又会变大，这就导致我们需要重新将 $r$ 放置到初始位置，重新计算所有的可能结果。有没有一种方法能够让 $(r - l)$ 不断变小呢？这样我们只需要考虑 $min(height[r], height[l])$ 带来的变化。 考虑一个通常的情况：$l$ 和 $r$ 处在不同的位置并且相距一定的距离（注意到 $l$ 一定是小于 $r$ 的）。我们假设 $height[l]$ 比 $height[r]$ 更高。那么此时，我们的盛水量由 $height[r]$ 决定的。为了寻求更大的盛水量，我们有四种做法： 向右移动 $r$: 这样我们的 $(r - l)$ 会增大，并且有可能遇到更大的 $height[r]$ ，但若是碰到更小的$height[r]$ ，也需要一些计算，有利有弊。 向左移动 $r$: 这样我们的 $(r - l)$ 会减小，但可以去寻求更大的 $height[r]$，有利有弊。 向右移动 $l$: 这样我们的 $(r - l)$ 会减少，就算碰到更大的 $height[l]$ 也会因为 $height[r]$ 的限制在，不管怎么样都是亏。 向左移动 $l$: 这样我们的 $(r - l)$ 会增大，但是可能会碰到更小的 $height[l]$ ，有利有弊。 到这一步，应该考虑那种走法？注意到以上四种走法中，有一种走法比较特殊，即向右移动 $l$，也可以称为没有前途。 如果我们将 $l$ 值减1（即向右移动 $l$），那么 $(r - l)$ 的值会减小，$min(height[r], height[l])$ 的值也只会降低或不变，而不会增加（我们假设了 $height[l]$ 比 $height[r]$ 高）。 有趣的地方来了：如果我们在 $l$ 和 $r$ 相遇以前，不断地重复这个步骤，那么计算得到的 $S$ 肯定不会高于没有移动 $l$ 时的 $S$ ！ 事实上，这个结果就是我们之前导出结论的强化：参见本文代码章节优化部分，第二个情况， $height[l]$ 比 $height[r]$ 高。这样一来，意味着我们可以跳过本轮内循环，开始下一轮内循环。这是因为就算我们继续计算下去，$S$ 也只会变低而不会变高。 如果按照往常（双循环）的思路，接下来我们应该向右移动 $r$ ，当然这又会导致上述的问题。这里我们换一个思路：这里我们已经计算出在 $[l, r]$ 区间内固定住 $r$ 后，$l$ 在所有不同位置处时 $S$ 的最大值，也就是我们已经考虑完了 $r$ 对 $l \\in [l, r - 1]$ 所有的可能性，进一步的，当 $r$ 和 $l$ 分别是列表的两个端点时，我们就不需要再考虑更多的问题。换句话说，为了穷举所有的可能性，我们现在只需要计算 $[l, r - 1]$ 这个区间中所有的可能 $S$。也就是说，我们仅仅通过一次比较和计算，就让输入列表的长度从 $n$ 下降到了 $n-1$。 当然你可能会问，这样做的前提是我们的假设 $height[l]$ 比 $height[r]$ 更高啊？事实上，当 $height[l]$ 比 $height[r]$ 低时，我们得到的新列表为$[l + 1, r]$ 。 那么聪明如你肯定就已经明白了问题解决的办法，只要我们不断重复上面的操作，我们就可以在 $\\mathcal{O}(n)$ 列举出所有的可能的 $S$，并且通过比较得出最终结果了。 本段描写更加偏向于对双指针思考的思路和证明，比较抽象。更为具体的描述相信网上随处可见。 事实上我认为双指针从中间往两边扩散也是可行的？那么扩散的初试条件是什么？这个有待进一步思考。 ","date":"2022-04-20","objectID":"/lc11/:3:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"双指针解法代码 int maxArea(int* height, int heightSize){ int minH = 0; int maxS = 0; int maxS_ = 0; int l = 0; int r = heightSize - 1; int maxL = height[l]; int maxR = height[r]; while (r \u003e l) { if (maxL \u003e maxR) { // 两数之中取其小 minH = maxR; } else { minH = maxL; } maxS_ = (r - l) * minH; // 临时盛水量 if (maxS_ \u003e maxS) { // 两数之中取其大 maxS = maxS_; } while (r \u003e l){ if (height[r] \u003e= height[l]) { l++; if (height[l] \u003e maxL) { maxL = height[l]; break; } } else { r--; if (height[r] \u003e maxR) { maxR = height[r]; break; } } } } return maxS; } 这里同样引入了一个小小改进。在 $(r-l)$ 不断减小的情况下，只有更大的 $height$ 才可能计算出更大的 $S$。因此在运行过程中记录碰到的最大的 $height[l]$ 和 $height[r]$，通过引入比较，来进一步减少计算的次数。同样的，这是本文代码章节优化部分，第一个情况， $height[l]$ 比 $height[r]$ 低部分思路的引用。 在代码中，我最开始采用了内置函数 fmax 和 fmin ，无论执行用时和内存消耗都很高。自定义 max 函数可以减少一部分内存消耗，但是最佳的做法还是简单 if 语句。 最终结果为： 执行用时: 76 ms，超过了 88% 的 c 提交记录。 内存消耗: 11.4 MB，超过了 67% 的 c 提交记录。 ","date":"2022-04-20","objectID":"/lc11/:4:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"结尾碎碎念 现在时间是2:37，原本只想随便写写，结果越写越多。这同样是一个梳理自己思路的过程，很多不清晰的事情，如果不加以思考，是很难落笔的。第一次写关于技术细节的文章，只能说比写浅入浅出教程有意义多了。 下一步学学怎么画图，图解还是非常重要的。有时间把 LC10 正则匹配也记录一下，用到了动态规划，也非常有用。 夜深了，该洗洗衣服睡觉了。 ","date":"2022-04-20","objectID":"/lc11/:5:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["AI"],"content":"简单记录下毕业设计的内容，以及解决问题的历程。","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":" 《基于人工智能的大气重点污染物浓度预测》 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:0:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"毕设灵感 很久之前，我就有将循环神经网络用在大气污染物浓度预测上的想法，可以自由选择题目的课程设计也就成了实现这个想法最好的平台。最初的想法非常简单：随便找几个监测站的大气污染物数据，把别人写好的 LSTM、GRU 之类的模型拿来用一用，再随便拟合一下就算大功告成。 考研初试结束后，我也总算有了一些时间继续做一些自己喜欢的工作。在学习的过程中，我发现了一个以前没有注意到过的领域 — 视频预测(Video Prediction)领域。这个方向的问题大概为：输入一个视频的前几帧，让你去预测下一帧的图像。针对这个领域的问题，非常具有代表性的一个工作就是 ConvLSTM，这是一篇NIPS2015的论文，讲的是利用 CNN 和 LSTM 结合，通过前几帧的卫星图像，来预测以后的卫星图像，进而对降水进行预测。我忽然意识到，如果将大气污染物的浓度分布作为原始输入，不也可以预测未来的污染物浓度分布吗？ 这激起了我的好奇心，检索了一下相关的工作，有一篇上海交大的硕士毕业论文完成了这项工作，作者使用的就是原始的 ConvLSTM。事实上，从 ConvLSTM 出现至今，视频理解方向的工作已经有了很多进步，从 Papers with Code 的网站上就可以看到。但是这些变化，还没有应用到大气污染物预测的领域，作为一个专业的学术易拉罐，这样的好机会我是不会放过的。 就这样，毕设难度一下子顶了上去，从原本的浓度单点预测，变成了现在的浓度分度预测。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:1:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"实验推进 深度学习，模型、数据、计算资源缺一不可。 模型方面，目前实现了 ConvLSTM 和 ConvGRU 两个模型，打算最后要是有时间还可以再做一下 Transformer 的结合，虽然说大概率没希望，因为数据量太少了，难以支撑起 Transformer 的效果。 数据方面，我原本想要自己安装一下 WRF-Chem 来跑些训练数据出来，先是根本找不到 WRF-Chem 完整的学习资料，导致安装摸爬滚打完之后，连软件该怎么运行都搞不清楚；后是排放清单数据拿不到，最终只好搁置了这个计划。转头去找学姐发文时用的数据，终于找到了大概有 550 多条数据，数据量堪忧。 计算资源方面，目前只有我寝室使用的 1050Ti。 总之就是前途非常渺茫。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"模型实现 代码仓库：DL_PM_Pred，公式如下： ConvLSTM $$ I_{t} = Sigmoid(Conv(X_t, W_{xi}) + Conv(H_{t-1}, W_{hi}) + b_i) \\\\ F_{t} = Sigmoid(Conv(X_t, W_{xf}) + Conv(H_{t-1}, W_{hf}) + b_f) \\\\ O_{t} = Sigmoid(Conv(X_t, W_{xo}) + Conv(H_{t-1}, W_{ho}) + b_o) \\\\ \\tilde{C_t} = Tanh(Conv(X_t, W*{xc}) + Conv(H_{t-1}, W_{hc}) + b_h) \\\\ C_t = F_t \\odot C_{t-1} + I_t \\odot \\tilde{C_t} \\\\ H_t = O_t \\odot Tanh(C_t)\\\\ Pred = ReLU(Conv(X_t, W*{xx}) + Conv(H_t, W_{xh}) + b_{p}) \\\\ $$ ConvGRU $$ R_{t} = Sigmoid(Conv(X_t, W_{xr}) + Conv(H_{t-1}, W_{hr})+b_r) \\\\ Z_{t} = Sigmoid(Conv(X_t, W_{xz}) + Conv(H_{t-1}, W_{hz})+b_z) \\\\ \\tilde{H_t} = Tanh(Conv(X_t, W*{xh})+Conv(R_t \\odot H_{t-1}, W_{rh}) + b_{h}) \\\\ H_t = Z_t \\odot H_{t-1} + (1 - Z_t) \\odot \\tilde{H} \\\\ Pred = ReLU(Conv(X_t, W_{xx}) + Conv(H_t, W_{xh}) + b_{p}) \\\\ $$ ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:1","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"数据分析 模拟范围 模拟范围如图： ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:2","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"变量选择 解包 wrfout 文件后，文件保存了 281 个变量，分别是： ['Times', 'XLAT', 'XLONG', 'LU_INDEX', 'ZNU', 'ZNW', 'ZS', 'DZS', 'VAR_SSO', 'U', 'V', 'W', 'PH', 'PHB', 'T', 'HFX_FORCE', 'LH_FORCE', 'TSK_FORCE', 'HFX_FORCE_TEND', 'LH_FORCE_TEND', 'TSK_FORCE_TEND', 'MU', 'MUB', 'NEST_POS', 'P', 'PB', 'FNM', 'FNP', 'RDNW', 'RDN', 'DNW', 'DN', 'CFN', 'CFN1', 'THIS_IS_AN_IDEAL_RUN', 'P_HYD', 'Q2', 'T2', 'TH2', 'PSFC', 'U10', 'V10', 'RDX', 'RDY', 'RESM', 'ZETATOP', 'CF1', 'CF2', 'CF3', 'ITIMESTEP', 'XTIME', 'QVAPOR', 'QCLOUD', 'QRAIN', 'QICE', 'QSNOW', 'QGRAUP', 'SHDMAX', 'SHDMIN', 'SNOALB', 'TSLB', 'SMOIS', 'SH2O', 'SMCREL', 'SEAICE', 'XICEM', 'SFROFF', 'UDROFF', 'IVGTYP', 'ISLTYP', 'VEGFRA', 'GRDFLX', 'ACGRDFLX', 'ACSNOM', 'SNOW', 'SNOWH', 'CANWAT', 'SSTSK', 'COSZEN', 'LAI', 'VAR', 'MAPFAC_M', 'MAPFAC_U', 'MAPFAC_V', 'MAPFAC_MX', 'MAPFAC_MY', 'MAPFAC_UX', 'MAPFAC_UY', 'MAPFAC_VX', 'MF_VX_INV', 'MAPFAC_VY', 'F', 'E', 'SINALPHA', 'COSALPHA', 'HGT', 'TSK', 'P_TOP', 'T00', 'P00', 'TLP', 'TISO', 'TLP_STRAT', 'P_STRAT', 'MAX_MSTFX', 'MAX_MSTFY', 'RAINC', 'RAINSH', 'RAINNC', 'SNOWNC', 'GRAUPELNC', 'HAILNC', 'CLDFRA', 'SWDOWN', 'GLW', 'SWNORM', 'OLR', 'XLAT_U', 'XLONG_U', 'XLAT_V', 'XLONG_V', 'ALBEDO', 'CLAT', 'ALBBCK', 'EMISS', 'NOAHRES', 'TMN', 'XLAND', 'UST', 'PBLH', 'HFX', 'QFX', 'LH', 'ACHFX', 'ACLHF', 'SNOWC', 'SR', 'SAVE_TOPO_FROM_REAL', 'EROD', 'CLDFRA2', 'RAINPROD', 'EVAPPROD', 'UST_T', 'ROUGH_COR', 'SMOIS_COR', 'DUSTLOAD_1', 'DUSTLOAD_2', 'DUSTLOAD_3', 'DUSTLOAD_4', 'DUSTLOAD_5', 'DRYDEPVEL', 'GRASET_1', 'GRASET_2', 'GRASET_3', 'GRASET_4', 'GRASET_5', 'DRYDEP_1', 'DRYDEP_2', 'DRYDEP_3', 'DRYDEP_4', 'DRYDEP_5', 'EDUST1', 'EDUST2', 'EDUST3', 'EDUST4', 'EDUST5', 'DRY_DEP_LEN', 'DRY_DEP_FLUX', 'WET_DEP_FLUX', 'EBIO_ISO', 'EBIO_API', 'LAI_VEGMASK', 'dvel_o3', 'PM2_5_DRY', 'PM10', 'DMS_0', 'PHOTR201', 'PHOTR202', 'PHOTR203', 'so2', 'sulf', 'no2', 'no', 'o3', 'hno3', 'h2o2', 'ald', 'hcho', 'op1', 'op2', 'paa', 'ora1', 'ora2', 'nh3', 'n2o5', 'no3', 'pan', 'hc3', 'hc5', 'hc8', 'eth', 'co', 'ol2', 'olt', 'oli', 'tol', 'xyl', 'aco3', 'tpan', 'hono', 'hno4', 'ket', 'gly', 'mgly', 'dcb', 'onit', 'csl', 'iso', 'hcl', 'ho', 'ho2', 'so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'naaj', 'naai', 'claj', 'clai', 'orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgba1j', 'orgba1i', 'orgba2j', 'orgba2i', 'orgba3j', 'orgba3i', 'orgba4j', 'orgba4i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha', 'seas', 'soila', 'nu0', 'ac0', 'corn', 'ISEEDARR_SPPT', 'ISEEDARR_SKEBS', 'ISEEDARR_RAND_PERTURB', 'ISEEDARRAY_SPP_CONV', 'ISEEDARRAY_SPP_PBL', 'ISEEDARRAY_SPP_LSM', 'BF', 'C1H', 'C2H', 'BH', 'C1F', 'C2F', 'C3H', 'C4H', 'C3F', 'C4F', 'PCB', 'PC', 'LANDMASK', 'LAKEMASK', 'SST', 'SST_INPUT'] 数据量相当夸张。为了减轻渣渣 1050Ti 的压力，需要从这些变量中选出主要变量。从这些变量中找出对 PM 影响较大的变量不是一件容易的事情，这里首先从数据的 shape 入手，将 shape 不是四维的数据首先排除可能，经筛选后，变量名、描述及翻译如下： 变量名 描述 翻译 U x-wind component x 轴风分量 V y-wind component y 轴风分量 W z-wind component z 轴风分量 PH perturbation geopotential 摄动位势高度 PHB base-state geopotential 基态位势高度 T perturbation potential temperature (theta-t0) 摄动势温 P perturbation pressure 摄动压 PB BASE STATE PRESSURE 基态压力 P_HYD hydrostatic pressure 流体静压 QVAPOR Water vapor mixing ratio 水汽混合比 QCLOUD Cloud water mixing ratio 云水混合比 QRAIN Rain water mixing ratio 雨水混合比 QICE Ice mixing ratio 冰混合比 QSNOW Snow mixing ratio 雪混合比 QGRAUP Graupel mixing ratio 霰粒混合比 TSLB SOIL TEMPERATURE 土壤温度 SMOIS SOIL MOISTURE 土壤湿度 SH2O SOIL LIQUID WATER 土壤液态水 SMCREL RELATIVE SOIL MOISTURE 相对土壤水分 CLDFRA CLOUD FRACTION 云分数 EROD fraction of erodible surface in each grid cell 每个网格单元中可侵蚀表面的分数 CLDFRA2 CLOUD FRACTION 云分数 RAINPROD TOTAL RAIN PRODUCTION RATE 总降雨率 EVAPPROD RAIN EVAPORATION RATE 降雨蒸发率 EDUST1 DUST emissions bin1 粉尘排放 EDUST2 DUST emissions bin2 粉尘排放 EDUST3 DUST emissions bin3 粉尘排放 EDUST4 DUST emissions bin4 粉尘排放 EDUST5 DUST emissions bin5 粉尘排放 DRY_DEP_LEN dry deposition velocity 干沉降速率 DRY_DEP_FLUX dry deposition flux 干沉降通量 WET_DEP_FLUX column wet scavening flux 柱湿清除通量 dvel_o3 O3 deposit","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:3","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"预实验 默认实验条件如下： 变量名 值 Model ConvGRU Learning Rate 0.0005 Batch Size 4 Kernel Size 5 Number of Epochs 200 Number of Steps 5 Number of Layers 3 Random Iter True Weight Decay 0 预实验 1 预实验 1 的目的是确定变量的选择。有两个方案可供选择： 方案 1 变量为全部的非零变量中去重后的变量，总计 78 个变量，变量名如下： key = ['PM10', 'PM2_5_DRY', 'U', 'V', 'QVAPOR','CLDFRA','QRAIN','QICE','QSNOW','QGRAUP','CLDFRA','so2','sulf','no2', 'no','o3','hno3','h2o2','ald','hcho','op1','op2','paa','ora1','ora2','nh3','n2o5','no3','pan','hc3','hc5','hc8','eth','co','ol2','olt','oli','tol','xyl','aco3','tpan','hono','hno4','ket','gly','mgly','dcb','onit','csl','iso','hcl','ho','ho2','so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'naaj','naai','claj','clai','orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha'] 实验结果如下： 方案 2  变量为上述 78 个变量中按照变量描述选择的 30 个变量： key = ['PM10', 'PM2_5_DRY', 'U', 'V', 'QVAPOR','CLDFRA','so2','no2', 'no','so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha'] 实验结果如下： 可以看出所选的 30 个变量效果甚至优于 78 个变量。因此后续实验以 30 变量进行。 预实验 2 预实验 2 讨论的问题为训练当中的两个 MSE 尖峰是如何产生的，猜测原因为数据中存在时序上不连续的数据。减少数据量，选择时序上一直连续的数据，进行实验： 发现不存在尖峰且效果良好，因此增加去除非时序连续数据代码，恢复数据量，重新实验： 可以看出尖峰的出现的确与数据时序不连贯有关，但尖峰依旧存在，猜测这是因为在优化的过程中出现了训练集上的局部过拟合。解决方法一般为增加 Batch Size，但是由于硬件原因不能实现。此处尝试增加正则化手段减少过拟合。 预实验 3 预实验 3 讨论的问题为 Batch Normalization 的作用。添加 BN 层，进行试验： 效果提升显著并且不再出现 MSE 上升，证明了上述猜测。因此后续采用带有 Batch Normalization 的网络。并且本次实验结果作为实验的基准效果。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:4","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"实验 基准实验 基准实验的参数选择如下： 变量名 值 Model ConvGRU Batch Size 4 Kernel Size 5 Number of Steps 5 Weight Decay 0 实验效果： 实验 1 实验 1 讨论的问题为 Weigth Decay 的影响。当 Weigth_Decay 为 1e-4 时： 当 Weight_Decay = 1e-5 时： 当 Weight_Decay = 1e-6 时： 结论 可以看出 Weigth_Decay 确实对过拟合有一定程度的缓和，但总体影响不大。 实验 2 实验 2 主要的讨论目标为 Kernel_Size 对训练效果的影响。当降低 Kernel_Size 为 4 时： 当增加 Kernel_Size 为 7 时： 结论 可以看出，减小 Kernel_Size 后，模型泛化能力下降，增加 Kernel_Size 后，模型过拟合现象更加严重。 实验 3 实验 3 主要讨论的影响因素为 Batch_Size 对训练效果的影响。当减小 Batch_Size 到 2 时： 当增加 Batch_Size 到 6 时： 结论 可以看出，增加或减小 Batch_Size 并没有明显影响。 实验 4 实验 4 的目的为探究 Num_Steps 对训练效果的影响。当减小 Num_Steps 到 3 时： 当增加 Num_Steps 到 7 时： 结论 可以看出，增加 Num_Steps 加剧了过拟合现象，减小 Num_Steps 降低了模型的泛化能力。 实验 5 实验 5 的目的为探究 ConvLSTM 的效果。当将模型切换为 ConvLSTM 后： 结论 可以看出模型泛化能力下降。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:5","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"总结 在上述的实验中，可以得出： Batch Size 对网络训练效果影响不大； Weigth Decay 的引入可以提升网络的泛化能力； Kernel Size、Num Steps 的增加会加剧网络过拟合，其减小又会引发泛化能力的下降； 相较于 ConvLSTM，ConvGRU 具有更好的泛化能力。 问题 事实上，上述实验结果的导出十分具有局限性。因为最后实验数据仅仅整理出 166 条训练集数据及 55 条测试集数据。在深度学习领域，这样的数据量是极小的。并且值得注意的是，训练集数据并没有分布在测试数据所在的时间段上，这也是训练集效果良好，测试集效果差距较大的原因之一。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:6","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"绘图 raise NotImplementedError() ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:3:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"工作时间线 2022/04/21及之前：完成了模型训练、预测的代码。 2022/04/22：从实验室区筛选了带有 PM 的 WRF 数据，大概有550条。 2022/04/23：确认数据，筛选合适的数据。最终数据分布在 3 个时间段上，共计 221 条。 2022/04/25：训练一部分数据，训练集 MSELoss 为 12.6。 2022/05/01: 实验完成。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:4:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["教程"],"content":"为了做毕设，这两天被 WRF 折磨的头疼了不少时间。网络上找到的教程往往是支离破碎，一人一个说法；WRF-Chem 官方教程又因为网络问题看不得，只能自己摸着石头过河。在此处记录一份完整的 WRF 安装教程，免得重蹈覆辙。","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":" 猴子都能懂的 WRF 教程，简称猴懂 WRF。 提示 如有问题欢迎与我联系😀 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:0:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"在这之前 在安装 WRF(The Weather Research and Forecasting Model) 之前，请先确定你的需求。比如要使用 WRF 来预测 PM ，这就要求你应当安装 WRF-Chem 而不仅仅是 WRF 。 本文内容包含 WRF 及 WRF-Chem 的编译。 有关 WRF-Chem 运行的部分，请参考 WRF-Chem User’s Guide。 在 WRF 官网有提供一个非常友善的 WRF 编译教程，但是该教程编译只包含 WRF 的部分，而且使用了 tcsh，与现在比较流行的 bash 可能会有一些出入。 有繁琐工作的地方就有自动化脚本，当然包括 WRF-Chem 的安装。这里也推荐我在Gitee上发现的一个全自动安装脚本，直接免除下面的所有工作，你仅仅需要根据自己的需求对脚本做一些简单的修改即可。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:1:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"平台准备 WRF 模型仅能运行在 Linux 系统上。为此，你可能需要： 一台安装了 Linux 系统的电脑 带有 Linux 系统的虚拟机 WSL(Windows Subsystem Linux) 中的其中一种方式来使用 Linux 系统。如果你的操作系统是 Windows 10 或者 Windows 11，那么 WSL 可能是一个最佳的选择。WSL 的安装可以参考微软官方的教程。本文中使用的系统为 Windows11 下的 WSL，安装的系统为 Ubuntu 20.04。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:2:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"文件下载及环境准备 首先要准备 WRF 和 WPS(WRF Pre-Processing System) 的安装文件 ，这两个程序的最新版本可以在 GitHub 很容易的下载下来，现在你需要新建一个文件夹，把 WRF 和 WPS 放在同一文件夹内（这个文件夹将会成为你放置 WRF 和 WPS 程序的文件夹），并将它们解压。对于 zip 类型的压缩包，你可以使用 unzip 命令来解压缩；对于 tar.gz 类型的压缩包，你需要使用 tar xzvf 命令来解压缩。 接下来，你可能需要安装一些编译器。编译 WRF 需要三个编译器，分别是 gfortran 、 cpp 和 gcc。你可以分别使用命令 which gfortran 、 which cpp 和 which gcc 来检查你的环境中是否包含这三个编译器，对于包含编译器的环境，which 命令将会返回对应地址，如果 which 命令没有任何反应，你可能需要手动安装这些编译器。不同的操作系统可能会有所差异，对于 Ubuntu 来说，你只需要运行 sudo apt-get install gfortran 来安装 gfortran 编译器，其它缺失的编译器同理。 除了三个编译器之外，你可能还需要安装 csh 和 perl 。你同样可以通过 sudo apt-get install 命令来安装它们。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:3:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"依赖库 在这里，你需要安装 5 个与 WRF 运行有关的库，分别是： mpich-3.0.4 netcdf-4.1.3 jasper-1.900.1 libpng-1.2.50 zlib-1.2.7 你可以通过点击上述链接，下载库的源代码。现在进入到放置 WRF 和 WPS 的文件夹中，在该文件夹内新建名为 Bulid_WRF 的文件夹，并在该文件夹内新建名为 LIBRARIES 的文件夹。将这些程序在 LIBRARIES 文件夹中逐一解压。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"添加环境变量 在进行以下的操作前，请先在终端（ bash ）中运行下面的代码来添加环境变量： export DIR=$HOME/software/Build_WRF/LIBRARIES # 请修改此条为你的 LIBRARIES 文件夹路径 export WRF_DIR=$HOME/software/WRF-4.3.3/ # 请修改此条为你解压 WRF 后文件夹的路径 export CC=gcc export CXX=g++ export FC=gfortran export FCFLAGS=-m64 export F77=gfortran export FFLAGS=-m64 export JASPERLIB=$DIR/grib2/lib export JASPERINC=$DIR/grib2/include export LDFLAGS=-L$DIR/grib2/lib export CPPFLAGS=-I$DIR/grib2/include export PATH=$DIR/mpich/bin:$PATH export PATH=$DIR/netcdf/bin:$PATH export NETCDF=$DIR/netcdf ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:1","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"mpich mpich 是并行计算所需要的库，你可以运行以下的代码来安装： cd mpich-3.0.4 # 进入解压后的 mpich-3.0.4 文件夹 ./configure --prefix=$DIR/mpich make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:2","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"netCDF netCDF 是编译 WRF 所需要的数据格式库，你可以通过运行以下的代码来安装： cd netcdf-4.1.3 # 进入解压后的 netcdf-4.1.3 文件夹 ./configure --prefix=$DIR/netcdf --disable-dap --disable-netcdf-4 --disable-shared make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:3","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"zlib 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd zlib-1.2.7 ./configure --prefix=$DIR/grib2 make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:4","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"libpng 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd libpng-1.2.50 ./configure --prefix=$DIR/grib2 make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:5","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"Jasper 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd jasper-1.900.1 ./configure --prefix=$DIR/grib2 make make install 请按照上述顺序来安装以避免预料之外的错误。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:6","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"WRF-Chem 对 WRF-Chem 来说，这里还需要一些额外的步骤。对于 WRF4 以下的版本，你可能需要下载单独的 WRF-Chem 编译所需的文件，并将这些文件解压到你的 WRF 文件夹内的 chem 文件夹中。对于 WRF4 以后的版本，则不需要进行此操作。 为了编译 WRF-Chem，这里需要添加一些环境变量： export WRF_EM_CORE=1 export WRF_NMM_CORE=0 export WRF_CHEM=1 export WRF_KPP=1 export YACC='/usr/bin/yacc -d' export FLEX=/usr/bin/flex export FLEX_LIB_DIR=/usr/lib/x86_64-linux-gnu/ export KPP_HOME=$HOME/software/WRF-4.3.3/chem/KPP/kpp/kpp-2.1 export WRF_SRC_ROOT_DIR=$HOME/software/WRF-4.3.3 export PATH=$KPP_HOME/bin:$PATH export SED=/usr/bin/sed export WRFIO_NCD_LARGE_FILE_SUPPORT=1 然后安装两个额外的库： sudo apt-get install yacc flex ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:7","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"编译 WRF 进入解压好的 WRF 文件夹，然后运行： ./configure 在这里你将会看到非常多不同的编译选项，一般选择 34 即可，这表示你使用 gcc 分布式并行编译 WRF。接下来，对于 nesting，直接选择默认选项即可。 接下来就可以对 WRF 进行编译，在此处你可以选择你想使用的 WRF 运行类型，有以下选项可以选择： em_real (三维真实情况) em_quarter_ss (三维理想状况) em_b_wave (三维理想状况) em_les (三维理想状况) em_heldsuarez (三维理想状况) em_tropical_cyclone (三维理想状况) em_hill2d_x (二维理想状况) em_squall2d_x (二维理想状况) em_squall2d_y (二维理想状况) em_grav2d_x (二维理想状况) em_seabreeze2d_x (二维理想状况) em_scm_xy (一维理想状况) 你可以根据自己的需求来选择编译哪个选项。一般应当选择 em_real 进行编译，以此为例，你应当运行： ./compile em_real 编译需要花费一段时间，对于 WRF，这可能会花费 30 分钟的时间，对于 WRF-Chem，编译可能需要 1 个小时。编译成功后，运行： ls -s main/*.exe 根据你编译选项的不同，你将会看到数个 .exe 文件。对于 em_real 选项，这四个文件分别是： wrf.exe real.exe ndown.exe tc.exe ⚠ 如果你编译失败，需要重新开始编译，请在重新执行本步骤前执行 ./clean。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:5:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"编译 WPS 进入解压后的 WPS 文件夹，然后执行: ./configure 这里你依旧会看到不同的编译选项，一般来说，此处应当选择 3 号选项。请注意，这里的编译选项应当和编译 WRF 时的选项一致，尽管序号可能有所不同。接下来就可以对 WPS 进行编译，执行： ./compile 这可能会花费一段时间，执行成功后，输入 ls -s *.exe，将会看到三个 .exe 文件，分别是：geogrid.exe，ungrib.exe 和 metgrid.exe。 至此，所有的编译工作已经完成。如果有时间，我会考虑增加： WPS 的运行 WRF 的运行 wrfout 数据的处理 等内容。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:6:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"嗦 嗨 嗨！-\u003e 害 嗨 嗨！","date":"2022-04-19","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ ","date":"2022-04-19","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"简介 😀 本人是一个跨考计算机二战的三非院校四大天坑本科待毕业生，最近正在刷 LeetCode，目标是数据结构张口就来。 ","date":"2022-04-19","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于本站 ","date":"2022-04-19","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"写 Blog 的想法 就在建站的约摸两周前，一战跨考计算机最终宣告失败，最主要的因素还是准备不足。在回顾考研这一年来碰壁原因的时候，我意识到，很多知识之所以自己不能学以致用，其原因往往还是用的太少，正所谓眼高手低，又或者说 talk is cheap。纸上得来终觉浅，绝知此事要躬行。 建立本站，通过将思维落实成文字的方式来加强自己的理解，我认为会是一种很有效的方式。 ","date":"2022-04-19","objectID":"/about/:2:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"施工时间线 😎 2022/04/19 Hello Hugo! 🥱 2022/04/22 页面施工基本完毕，等待上线。 😛 2022/04/22 正式上线 GitHub Pages！ ✈️ 2022/04/25 迁移至 netlify ","date":"2022-04-19","objectID":"/about/:2:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"与我联系 📫 唯一指定邮箱: blathers233@outlook.com 🐱 LeetCode 主页: @susasasa 🤖 Gitee 主页: @blathers 👾 GitHub 主页(不经常出没): @blathers23 ","date":"2022-04-19","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 😧博主理解粗浅，如有错误还请包涵，或联系博主订正 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:0:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅰ. 安装 MSYS2 博主选择使用 MSYS2 管理 g++ 的版本，有关 MSYS2 的介绍请参照此处。 首先安装 MSYS2。这里使用清华大学的镜像站 在安装过程中，可能会碰到安装进度卡在 66% 的情况，这时候我们取消安装再重新打开安装程序安装到原位置即可。 安装完成后我们为 MSYS2 配置清华镜像，提高下载的速度和稳定性，同样按照镜像站中的教程操作。 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:1:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅱ. 下载 g++ 和 gdb 首先更新核心软件包，运行指令： pacman -Syu 最后安装 g++，运行指令： pacman -S gcc 然后下载 gdb，运行指令： pacman -S mingw-w64-x86_64-gdb ","date":"2021-03-14","objectID":"/vscode_and_msys2/:2:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅲ. 配置环境变量 将 MSYS2 安装地址下的 \\usr\\bin 加入到Path变量。然后启动 powershell，输入指令 g++ -v检查安装是否成功。 如果使用 everything 搜索 g++.exe 是搜索不到 \\usr\\bin 文件夹中的，就算它就在文件夹里面。 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:3:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅳ. 配置 VSCode 在 VSCode 扩展商店中搜索 C++，然后安装此扩展： 打开一个 C++ 语言程序，然后在 VSCode 中运行，此时会弹出环境选择框，这里我们选择 GDB，即第一项： 然后选择 g++ 进行编译，此时会报错，显示 miDebuggerPath 不存在： 这里我们编辑这一项，刚刚在第二步，我们下载了 gdb，其安装位置在 \\mingw64\\bin 下，于是我们将这一行改为： 保存，就可以愉快的使用快捷键调试辣👏！ ","date":"2021-03-14","objectID":"/vscode_and_msys2/:4:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 ✍️ go verison 1.15.8 使用 VSCODE 配置 go 开发环境时遇到了一些问题，主要是无法下载 Go modules，这里简要记一下配置方法（ Windows 系统）： ","date":"2021-02-13","objectID":"/golang_hello_world/:0:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"1. GO111MODULE ","date":"2021-02-13","objectID":"/golang_hello_world/:1:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"环境变量方法： 打开环境变量，为用户新建环境变量，变量名为 GO111MODULE，变量值为 on。 ","date":"2021-02-13","objectID":"/golang_hello_world/:1:1","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"命令方法： go env -w GO111MODULE='on' 两种方法取其一即可。 ","date":"2021-02-13","objectID":"/golang_hello_world/:1:2","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"2. GOPROXY 此处博主比较了 goproxy.io、阿里云镜像、goproxy.cn 三家镜像代理服务，博主自测 goproxy.cn 效果最佳。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"环境变量方法： 打开环境变量，为用户新建环境变量，变量名为 GOPROXY，变量值为 https://goproxy.cn,direct。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:1","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"命令方法： go env -w GOPROXY='https://goproxy.cn,direct' 两种方法取其一即可。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:2","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"3.go.mod 在代码调试前，还需要在命令行中执行 go mod init ****.go，****处为模块名称。 ","date":"2021-02-13","objectID":"/golang_hello_world/:3:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 ✍️ Gitalk版本 1.7.0；Gridea版本 0.9.2。 使用 Gridea 配置 Gitalk 功能，进入网页，登录 GitHub 提示 403 错误。这是由于 Gitalk 使用的反向代理网站在 2021 年 1 月 31 日起开始限制使用。参照这篇文章，总结 Gridea 的解决方式如下（博主使用了 Windows 系统）： 使用 everything 搜索 gitalk.ejs 可以找到如下文件： 博主的 Gridea 安装地址为： D:/Blog_Gridea，站点源文件的保存位置为 D:/Blog_Gridea_Documents，博主并不确定应该修改哪一项，于是采用了这两者都修改的方式。这里以修改 D:/Blog_Gridea_Documents 中的文件为例，这里我们只需要修改站点源文件保存位置内的文件。博主目前使用的主题是 notes，因此打开 D~~:/Blog_Gridea_Documents/themes/notes/templates/includes/gitalk.ejs，将下述代码添加到第16行（即 new Gitalk 中）（这里要注意格式） proxy: '\u003c%= commentSetting.gitalkSetting.proxy %\u003e' 然后打开 D:/Blog_Gridea_Documents/config/setting.json，将下述代码添加到第26行（即 gitalkSetting 中）（同样注意格式） \"proxy\": \"https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token\" ⚠️ 博主将 D:/Blog_Gridea 下的文件做了上述同样的处理，这里要注意 D:/Blog_Gridea 中的 theme 和 config 文件夹在 default_files 下。博主并不清楚是否只做一处修改就可以解决Bug。 最后，只需要在 Gridea 中点击同步，等待网站部署完成即可。以上，就是解决该 Bug 的全部操作。 2021/2/14 订正 （小问号：,接 ‘~~’ 会导致删除线不能正确出现） 2022/4/26 补充上条： 这是因为你多打了个 ~~。 ","date":"2021-02-13","objectID":"/gitalk/:0:0","tags":["Gridea","Bug","Gitalk"],"title":"记录Gitalk的一个Bug","uri":"/gitalk/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 😵在书写本文时博主几乎忘记了操作顺序，可能与实际有些许所出入（不影响操作的正确性），会在未来进行订正。 😀书接上回，我们搭建了自己的 Blog 网站，并且可以使用自动分配的域名在任意时间和设备上访问。但美中不足的是，网站的网址实在是太太太太长了，例如本博客的网站地址即为 https://coding-pages-bucket-3524618-8350701-12972-499298-1301281690.cos-website.ap-hongkong.myqcloud.com ，这明显是非常难记且不符合美学的。接下来我们使用腾讯云购买域名并设置到自己的博客上。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:0:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅰ. 在腾讯云上选择一个合适的域名并购买 在腾讯云网站上搜索并购买一个域名。在提交订单时注意将推荐产品中免费的 SSL 证书勾选上白嫖的谁不爱呢。 购买之后，按照提示进行实名认证，并等待实名认证成功。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:1:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅱ. 自定义域名设置 回到 Coding 中项目页面，进入持续部署-静态网站页面，点击建立的网页（例如博主的“泡面\u0026榨菜”） 进入页面信息，注意横栏，点击自定义域名，注意最右边，点击新建域名。并填入第一步购买的域名。填写完成后我们忽略提示，复制表格中的“CNAME 指向”信息。 前往腾讯云控制台，搜索域名注册，找到购买的域名，点击解析。 点击添加记录，主机记录输入 @，记录类型选择 CNAME，记录值粘贴刚才复制的信息，点击确认。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:2:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅲ. SSL证书的部署 回到 Coding 页面自定义域名处，点击证书状态，注意页面右方的快速上手栏，稍作休息，等待证书签发（这里博主等待了约 30 分钟），签发完成后微信会有相关通知。 签发完成后，我们选择一键部署。部署类型选择 CDN，点击确定，进入配置证书页面。选择刚购买的域名，证书来源选择腾讯云托管证书，证书列表选择刚才的证书，回源协议选择 HTTPS，点击提交。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:3:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅳ. 重新配置 Gridea 打开 Gridea 软件，点击远程，将域名更换为我们购买的域名，在 CNAME 中输入第二步中复制的“CNAME 指向”信息，点击检测远程连接，此时应当连接正常。然后点击保存，并同步，网站需稍等 5 分钟左右部署完成。 以上，就完成了给 Blog 网站设置自己的域名的全部操作，现在就可以使用新域名访问网站了。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:4:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 由于介绍的非常详细，本文不再重复啰嗦，有关 Gridea 的简介请见此。 ","date":"2021-02-12","objectID":"/hello_gridea/:0:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"Ⅰ. Gridea 的安装 Gridea 的下载地址 以 Windows 系统位例，安装完成后，我们注意软件左边栏，选择远程项，并将其中的平台项改为 Coding Pages，继续以下的工作。 ","date":"2021-02-12","objectID":"/hello_gridea/:1:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"Ⅱ. 部署到 Coding Pages Gridea 提供了将博客部署到 GitHub Pages、Coding Pages 和通过 SFTP 的方式上传到自己的服务器的功能。有关使用 GitHub 的 Gridea 部署方式，官方给出了一个十分详细的教程。但是由于网络的原因，GitHub 不能成为博主的优先选择，因此本教程采用腾讯系的 Coding Pages 进行部署。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"① .创建一个 Coding 账号，并创建一个 Token。 点击 Coding 进行注册。登录至工作台主页后（****.coding.net/user），注意页面右上角自己的头像，在悬停时弹出的菜单中选择个人账户设置；注意左侧边栏，选择访问令牌，进入访问令牌页面（****.coding.net/user/account/setting/tokens）。将页面中的令牌用户名填入到 Gridea 软件令牌用户名一栏中。点击新建令牌，令牌描述以便于区分为佳，例如“Gridea Site”。选择权限勾选 project:depot，即完全的仓库控制权限。点击确定，将会生成一个新令牌，请务必将令牌复制到本地保存，因为页面关闭后令牌将无法在页面上查看。将生成的令牌填入到 Gridea 软件令牌一栏中。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:1","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"②.创建一个公开仓库，以存放构建后的网站。 回到工作台主页，注意左侧边栏，选择项目，单击新建项目，选择 DevOps 项目。这时项目名称可能将无法更改，这是 Coding 网站的引导示例项目，只需随着教程操作后重新回到工作台并新建项目即可。选择 DevOps 项目，并为自己的项目起一个好听的名字虽然并没有什么用，点击完成创建，进入项目主页（****.coding.net/p/**/）。注意左侧边栏，选择代码仓库项，并点击新建代码仓库。为自己的仓库起一个好听的名字同样也没什么用，勾选生成 README 文件，勾选公开仓库，完成创建。注意项目名所在的横栏，点击设置，注意到代码仓库名称中给出的“⚠️修改仓库名称将导致仓库的访问 URL 改变，在此之前的 URL 地址将失效。Git 仓库地址修改方法”附带了代码，其格式为： git remote set-url origin https://e.coding.net/“字段 A”/“字段 B”/“字段 C”.git 打开Gridea软件，在仓库名称中填入“字段 C”，在仓库用户名中填入“字段 A”/“字段 B”，在分支中填入 master。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:2","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"③.部署静态网站。 点击左侧边栏持续部署，选择静态网站，按照提示配置腾讯云权限，完成实名认证并新建静态网站。随便给网站起一个名字，点击确定，网站将进行部署。稍等至网站部署成功，点击访问，访问的网址即为 Blog 的网址。打开 Gridea 软件，将网址复制到域名中，注意 “https://” 不要重复。此时点击软件左下角的检测远程连接，如果一切配置正确的话，会出现“远程连接成功”字样。点击保存，然后点击软件右下角的同步，就可以将网页部署到 Coding Pages 上。稍等约5分钟左右再次访问 Blog 网站即可访问成功。 以上，就完成了使用 Gridea 将博客部署到 Coding Pages 上的全部步骤。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:3","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"}]