[{"categories":["C"],"content":"通过将LeetCode中的问题与考研大纲中所考内容对照性练习，来提高编程能力。编程语言选择C语言，更为通用。","date":"2022-07-11","objectID":"/datastructurewithc/","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":" 技巧 按照去年考研翻车的经验，编程能力的欠缺是非常严重的问题。期望通过将LeetCode中的问题与考研大纲中所考内容对照性练习，来提高编程能力。编程语言选择C语言，更为通用。 ","date":"2022-07-11","objectID":"/datastructurewithc/:0:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1. 算法设计部分 ","date":"2022-07-11","objectID":"/datastructurewithc/:1:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.1 递归 LC 50. Pow(x, n) 一个比较笨的写法，但是思想上是没有什么大问题的： double myPow(double x, int n) { double temp; double Pow(double x, int n) { if (n != 1) { if (n % 2 != 0) { temp *= x; } return Pow(x * x, n / 2); } else { return x * temp; } } if (n \u003c -1) { x = 1 / x; if (n % 2 != 0) { temp = x; } return Pow(x * x, -(n / 2)); // 规避int取负超出转范围 } else if (n == 0) { return 1; } else if (n == -1) { return 1 / x; } else { temp = 1; return Pow(x, n); } } 简练风格： double myPow(double x, int n) { double Pow(double x, int n) { if (n != 0) { return n % 2 == 0 ? Pow(x * x, n / 2) : Pow(x * x, n / 2) * x; } else { return 1.0; } } return n \u003e= 0 ? Pow(x, n) : n % 2 == 0 ? Pow(1 / (x * x), -(n / 2)) : Pow(1 / (x * x), -(n / 2)) / x; } 警告 今日吃瘪： 先动脑子后动手。 用C语言尽量避免在所给函数外编程，否则容易造成本地测试结果和提交测试结果不同！！！ 注意C语言int数据类型的范围。 剑指 Offer 65. 不用加减乘除做加法 代码： int xor, carry; int add(int a, int b) { xor = a ^ b; carry = (unsigned int)(a \u0026 b) \u003c\u003c 1; if (carry != 0) { return add(xor, carry); } else { return xor; } } 简练风格： int add(int a, int b) { return b == 0 ? a : add(a ^ b, (unsigned int)(a \u0026 b) \u003c\u003c 1); } 解题思路： 考虑一般加法过程219 + 101，最低位9 + 1 = 10，发生进位。原本加法过程可以写为无进位和 + 进位值，即219 + 101 = 310（无进位和）+ 010（进位值）= 320。考虑二进制加法过程同理，可以每次求出无进位和与进位值，并相加。 对二进制而言，无进位和即为XOR得到的值，即相同为0，相异为1；进位值为AND，即仅当两数均为1时，发生进位，因此二进制加法可以表示为：a + b = (a ^ b) + ((a \u0026 b) « 1)。注意第二项((a \u0026 b) « 1)，由于是AND和左移运算，因此该项从最低位到第一个非零位的长度必然大于b。因此如果下一步令a = (a ^ b)，b = ((a \u0026 b) « 1)，并重复此过程，那么在有限步数内b终将等于0，此时a + b的值即等于a。 警告 今日吃瘪：C对int类型的左移会有数据范围的限制，当超出int数据表示的范围会报错显示，这时需要考虑unsigned int类型（闭嘴给我算就是了！）。 面试题 08.05. 递归乘法 代码： int multiply(int A, int B) { return B == 1 ? A : B % 2 == 0 ? multiply(A + A, B / 2) : multiply(A + A, B / 2) + A; } 剑指 Offer 51. 数组中的逆序对 注意到数组长度最长为50000，考虑到这是一道hard题，暴力解$\\mathcal{O}(n^2)$八成会TLE。 归并排序解题代码： int mergeSort(int l, int r, int* nums, int* tmp) { // 退出条件 if (l \u003e= r) { return 0; } // 递归划分 int m = (l + r) / 2; int res = mergeSort(l, m, nums, tmp) + mergeSort(m + 1, r, nums, tmp); // 合并阶段 int i = l, j = m + 1; for (int k = l; k \u003c= r; k++) { tmp[k] = nums[k]; } for (int k = l; k \u003c= r; k++) { if (i == m + 1) { nums[k] = tmp[j++]; } else if (j == r + 1 || tmp[i] \u003c= tmp[j]) { nums[k] = tmp[i++]; } else { nums[k] = tmp[j++]; res += m - i + 1; } } return res; } int reversePairs(int* nums, int numsSize){ int *tmp = malloc(sizeof(int) * numsSize); return mergeSort(0, numsSize - 1, nums, tmp); } 剑指 Offer II 076. 数组中的第 k 大的数字 归并排序代码： int mergeSort(int l, int r, int *nums, int *tmp) { if (l \u003e= r) { return 0; } int m = (l + r) / 2; mergeSort(l, m, nums, tmp); mergeSort(m + 1, r, nums, tmp); for (int k = l; k \u003c= r; k++) { tmp[k] = nums[k]; } int i = l, j = m + 1; for (int k = l; k \u003c= r; k++) { if (i == m + 1) { nums[k] = tmp[j++]; } else if (j == r + 1 || tmp[i] \u003e tmp[j]) { nums[k] = tmp[i++]; } else { nums[k] = tmp[j++]; } } return 0; } int findKthLargest(int* nums, int numsSize, int k){ int *tmp = malloc(sizeof(int) * numsSize); mergeSort(0, numsSize - 1, nums, tmp); return nums[k - 1]; } 归并排序表现不佳，用时12ms。 C语言内置函数qsort可以快速排序列表，声明如下： void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*)) 参数： base – 要进行排序的列表； nitems – 由base指向的数组中元素的个数； size – 数组中每个元素的大小，以字节为单位； compar – 用于比较两个元素的函数。 借用内置函数qsort，快速排序代码如下： int cmp(const void *a, const void *b) { return *(int*)b - *(int*)a; } int findKthLargest(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof(int), cmp); return nums[k - 1]; } 耗时为8ms。仍有提升空间。 堆排序解法： void maxHeapify(int* a, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l \u003c heapSize \u0026\u0026 a[l] \u003e a[largest]) { largest = l; } if (r \u003c heapSize \u0026\u0026 a[r] \u003e a[largest]) { largest = r; } if (largest != i) { int t = a[i]; a[i] = a[largest], a[largest] = t; maxHeapify(a, largest, heapSize); } } void buildMaxHeap(int* a, int heapSize) { for (int i = heapSize / 2; i \u003e= 0; --i) { maxHeapify(a, i, heapSize); } } int findKthLargest(int* nums, int numsSize, int k) { int heapSize = numsSize; buildMaxHeap(nums, heapSize); for (int i = numsSize - 1; i \u003e= numsSize - k + 1; --i) { int t = nums[","date":"2022-07-11","objectID":"/datastructurewithc/:1:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.2 分治策略 典型实列：二分搜索、归并排序、快速排序。 ","date":"2022-07-11","objectID":"/datastructurewithc/:1:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.3 贪心算法 ","date":"2022-07-11","objectID":"/datastructurewithc/:1:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.4 动态规划 剑指 Offer II 101. 分割等和子集 NP完全问题，动态规划求解。 bool canPartition(int* nums, int numsSize) { if (numsSize \u003c 2) { return false; } int sum = 0, maxNum = 0; for (int i = 0; i \u003c numsSize; ++i) { sum += nums[i]; maxNum = fmax(maxNum, nums[i]); } if (sum \u0026 1) { return false; } int target = sum / 2; if (maxNum \u003e target) { return false; } int dp[numsSize][target + 1]; memset(dp, 0, sizeof(dp)); for (int i = 0; i \u003c numsSize; i++) { dp[i][0] = true; } dp[0][nums[0]] = true; for (int i = 1; i \u003c numsSize; i++) { int num = nums[i]; for (int j = 1; j \u003c= target; j++) { if (j \u003e= num) { dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num]; } else { dp[i][j] = dp[i - 1][j]; } } } return dp[numsSize - 1][target]; } 事实上注意到状态转移方程当前行只与上一行有关，因此可以原地dp。 代码： bool canPartition(int* nums, int numsSize) { if (numsSize \u003c 2) { return false; } int sum = 0, maxNum = 0; for (int i = 0; i \u003c numsSize; ++i) { sum += nums[i]; maxNum = fmax(maxNum, nums[i]); } if (sum \u0026 1) { return false; } int target = sum / 2; if (maxNum \u003e target) { return false; } int dp[target + 1]; memset(dp, 0, sizeof(dp)); dp[0] = true; for (int i = 0; i \u003c numsSize; i++) { int num = nums[i]; for (int j = target; j \u003e= num; --j) { dp[j] |= dp[j - num]; } } return dp[target]; } ","date":"2022-07-11","objectID":"/datastructurewithc/:1:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.5 线性规划 ","date":"2022-07-11","objectID":"/datastructurewithc/:1:5","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"1.6 网络流 ","date":"2022-07-11","objectID":"/datastructurewithc/:1:6","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2 内部排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.1 排序的基本概念 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.2 插入排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.3 起泡排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.4 简单选择排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.5 希尔排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:5","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.6 快速排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:6","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.7 堆排序 代码： void maxHeapify(int* nums, int i, int heapSize) { int l = i * 2 + 1, r = i * 2 + 2, largest = i; if (l \u003c heapSize \u0026\u0026 nums[l] \u003e nums[largest]) { largest = l; } if (r \u003c heapSize \u0026\u0026 nums[r] \u003e nums[largest]) { largest = r; } if (largest != i) { int temp = nums[i]; nums[i] = nums[largest]; nums[largest] = temp; maxHeapify(a, largest, heapSize); } } void buildMaxHeap(int* nums, int heapSize) { for (i = heapSize / 2; i \u003e= 0; --i) { maxHeapify(nums, i, heapSize); } } void Sort(int* nums, int numsSize) { int temp, heapSize = numsSize; for (i = numsSize; i \u003e 0; --i) { temp = nums[0]; nums[0] = nums[temp]; nums[heapSize - 1] = temp; heapSize -= 1; maxHeapify(nums, 0, heapSize - 1); } } 时间复杂度：$\\mathcal{O}(nlogn)$ 空间复杂度：递归实现$\\mathcal{O}(logn)$、非递归实现$\\mathcal{O}(1)$ 稳定性：不稳定 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:7","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.8 二路归并排序 代码： void mergeSort(int l, int r, int *nums, int *tmp) { if (l \u003e= r) { return; } int m = (l + r) / 2; mergeSort(l, m, nums, tmp); mergeSort(m + 1, r, nums, tmp); for (int k = l; k \u003c= r; k++) { tmp[k] = nums[k]; } int i = l, j = m + 1; for (int k = l; k \u003c= r; k++) { if (i == m + 1) { nums[k] = tmp[j++]; } else if (j == r + 1 || tmp[i] \u003c= tmp[j]) { nums[k] = tmp[i++]; } else { nums[k] = tmp[j++]; } } } void Sort(int *nums, int numsSize) { int *tmp = malloc(sizeof(int) * numsSize); mergeSort(0, numsSize - 1, nums, tmp); } 时间复杂度：$\\mathcal{O}(nlogn)$ 空间复杂度：$\\mathcal{O}(n)$ 稳定性：稳定 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:8","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.9 基数排序 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:9","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.10 各种内部排序算法的分析和比较 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:10","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"2.11 内部排序算法及应用 ","date":"2022-07-11","objectID":"/datastructurewithc/:2:11","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3 查找 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.1 查找的基本概念 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.2 顺序查找及其性能分析 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.3 折半查找及其性能分析 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.4 二叉排序树及其性能分析 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.5 平衡二叉树定义及其转换方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:5","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.6 B-树及其基本操作、B+树的基本概念 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:6","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.7 散列（hash）表构造及其查找方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:7","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"3.8 常用查找算法的分析及应用 ","date":"2022-07-11","objectID":"/datastructurewithc/:3:8","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"4 图 ","date":"2022-07-11","objectID":"/datastructurewithc/:4:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"4.1 图的基本概念和术语 ","date":"2022-07-11","objectID":"/datastructurewithc/:4:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"4.2 图的存储结构和基本操作 ","date":"2022-07-11","objectID":"/datastructurewithc/:4:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"4.3 图的遍历 ","date":"2022-07-11","objectID":"/datastructurewithc/:4:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"4.4 图的基本应用 ","date":"2022-07-11","objectID":"/datastructurewithc/:4:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"5 树与二叉树 ","date":"2022-07-11","objectID":"/datastructurewithc/:5:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"5.1 树的概念 ","date":"2022-07-11","objectID":"/datastructurewithc/:5:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"5.2 二叉树 ","date":"2022-07-11","objectID":"/datastructurewithc/:5:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"5.3 树、森林 ","date":"2022-07-11","objectID":"/datastructurewithc/:5:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"6 数组与广义表 ","date":"2022-07-11","objectID":"/datastructurewithc/:6:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"6.1 多维数组的存储及数组元素的地址计算方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:6:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"6.2 特殊矩阵（三角矩阵、对称矩阵、多对角矩阵等）的压缩存储方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:6:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"6.3 稀疏矩阵概念及存储方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:6:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"6.4 广义表定义及存储方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:6:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"7 栈、队列 ","date":"2022-07-11","objectID":"/datastructurewithc/:7:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"7.1 栈和队列的基本概念 ","date":"2022-07-11","objectID":"/datastructurewithc/:7:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"7.2 栈和队列的顺序存储结构及操作实现 ","date":"2022-07-11","objectID":"/datastructurewithc/:7:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"7.3 栈和队列的链式存储结构及操作实现 ","date":"2022-07-11","objectID":"/datastructurewithc/:7:3","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"7.4 栈和队列的应用及其算法性能分析 ","date":"2022-07-11","objectID":"/datastructurewithc/:7:4","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"8 线性表 ","date":"2022-07-11","objectID":"/datastructurewithc/:8:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"8.1 线性表的定义和基本操作 ","date":"2022-07-11","objectID":"/datastructurewithc/:8:1","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"8.2 线性表的实现 ","date":"2022-07-11","objectID":"/datastructurewithc/:8:2","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["C"],"content":"9 绪论 数据结构的基本概念 数据结构的分类 数据类型和抽象数据类型 逻辑结构、物理结构的概念 算法的定义和特性 算法的设计目标 算法的时间、空间复杂度的概念 算法的时间、空间复杂的分析方法 ","date":"2022-07-11","objectID":"/datastructurewithc/:9:0","tags":["C","数据结构","算法"],"title":"使用C语言学习算法及数据结构","uri":"/datastructurewithc/"},{"categories":["Linux"],"content":"Linux只要花点功夫配置好就会很好用？","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":" 简介 最近觉得Linux中的好多小点值得一记，但是为此单开一帖体量不足又不值得。因此打算将简单零碎的点记载到这篇文章中。操作系统为Ubuntu22.04，不知道对于其它版本的Linux是否通用。 Jul 11 更新：历史性和Windows达成和解，日常使用Linux还是不方便，如有需求可以使用WSL。 Sep 26 更新：学不进去折腾了Fedora36，使用体验和Ubuntu差距还是蛮大的，更新一些在Fedora36上使用的小技巧，同时会在每个技巧前标注系统。 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:0:0","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"软件包安装相关 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:1:0","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"APT代理 Ubuntu22.04 Linux的代理十分简单，对于Ubuntu系统来说，可以在网络设置里打开手动代理并填写代理地址，这实际上就是设置了环境变量： export http_proxy=192.168.0.0:8080 export https_proxy=192.168.0.0:8080 相信这一点对于很多其他的Linux版本都是相通的。但是这种代理模式并不能改变APT的网络链接，APT依旧会采取直连模式。为此，需要使用命令： sudo apt command -o Acquire::http::proxy=\"http://192.168.0.0:8080/\" 来设置相应的代理。 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:1:1","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"DNF代理 Fedora36 对于DNF的软件包，很多源在国内都有镜像，可以达到不错的下载速度。最近（2022.9.26）在下载安装wine时，使用官方源下载经常失败，而TUNA也没有提供镜像，只好使用代理的方式解决。修改位于/etc/yum.repos.d/下的winehq.repo： sudo vim /etc/yum.repos.d/winehq.repo 在最后一行添加代理信息，例如： [WineHQ] name=WineHQ packages type=rpm-md baseurl=https://dl.winehq.org/wine-builds/fedora/36 gpgcheck=1 gpgkey=https://dl.winehq.org/wine-builds/winehq.key enabled=1 proxy=http://192.168.0.0:8080 在更新及下载软件包时即可使用代理加速下载，对于其它软件包也是同理。 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:1:2","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"系统相关 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:2:0","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"windows系统模拟：Wine 参考：Wine的食用方式。 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:2:1","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["Linux"],"content":"GNOME桌面Main Manu编辑：Alacarte Fedora36 最近在Fedora系统上配置Aria2和AriaNG时发现使用非常不方便，一方面我需要在terminal中启动aria2，另一方面又需要使用Chrome启动Aria2NG，步骤繁杂不能做到一键启动。由此我想到了创建一个主菜单启动图标的方法。 首先编写一个启动Aria2和AriaNG的脚本： gnome-terminal -- aria2c --enable-rpc --rpc-allow-origin-all google-chrome /Your_AriaNg_Path/index.html 然后安装主菜单编辑器Alacarte： sudo dnf install alacarte 最后在编辑器中添加启动脚本，并设置图标及名称，就可以方便的在主菜单启动Aira2。 ","date":"2022-06-18","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/:2:2","tags":["Linux"],"title":"优雅地使用Linux","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux/"},{"categories":["CS"],"content":"CS:APP读书笔记及问题记录。","date":"2022-06-10","objectID":"/csapp/","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":" 简介 本文是CSAPP的读书笔记及问题记录。由于时间、兴趣原因，比较感兴趣的章节未能完成习题，希望能在空闲时将作业及实验补上；例如硬件设计等不感兴趣的章节则进行了大篇幅的略过。 ","date":"2022-06-10","objectID":"/csapp/:0:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 1 clang中stdio.h的主要内容？include的作用? AVX512指令集到底是什么？为什么不同的指令集可以影响程序执行的速度？ 什么是操作系统内核(kernel)？ 解释性语言和编译性语言之间有什么主要区别？ 并发和并行。 线程级并发：CPU同时执行多个控制流，在进程中切换。超线程（hyperthreading）。 指令级并行：同时处理多条指令。流水线（pipelining）、超标量（superscalar）。 单指令、多数据并行：允许一条指令产生多个并行的操作。SIMD。 ","date":"2022-06-10","objectID":"/csapp/:1:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 2 汇编语言、机器语言。 汇编语言是一种低级语言，文本。 机器语言无需翻译计算机即可理解，二进制。 计算机的字长？ 计算机的字长（word size）取决于数据总线的宽度，指明指针数据的标称大小（nominal size），限制了虚拟地址的范围。对于总线长度为$w$的计算机，其虚拟地址的范围为$2^w - 1$。 C数据类型的典型大小（以字节为单位）。 有符号 无符号 32位 64位 char unsigned char 1 1 short unsigned short 2 2 int unsigned int 4 4 long unsigned long 4 8 int32_t uint32_t 4 4 int64_t uint64_t 8 8 char * 4 8 float 4 4 double 8 8 int32_t和int64_t的出现是为了防止不同编译系统编译相同声明出现数据大小不一的情况。 声明指针。 对于任何数据类型T，声明T *p，表明p是一个指针对象，指向一个类型为T的对象。 字节存储顺序。 最低有效位字节在最前面的方式，称为小端法（little endian）；最高有效位字节在最前面的方式，称为大端法（big endian）。比较新的微处理器使用双端法（bi-endian），可以把机器配置为大端或者小端来运行。一旦选择了操作系统，字节顺序随之固定。 为什么相同的程序在不同机器或系统上编译得到的二进制代码不同？既然不同，那为什么exe文件，deb文件，他们的工作原理又是什么？ 异或逆元（a^a = 0）: void inplace_swap(int *x, int *y) { *y = *x ^ *y; *x = *x ^ *y; *y = *x ^ *y; } 移位运算。 C语言中移位运算不会修改总位数。对于有符号数，几乎所有的编译器/机器的组合都使用算术右移（考虑正负号），对于无符号数，必须使用逻辑右移。 C语言中移位运算符的优先级小于加减法。 整数隐式转换。 当执行一个运算时，假设同时存在有符号数和无符号数，那么C会转换有符号数为无符号数，并且假设所有的数都是非负的。当把short转换为unsigned时，先转换长度，后转换符号，这是C语言标准所要求的。 第二章至2.3.2，暂且跳过。 ","date":"2022-06-10","objectID":"/csapp/:2:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 3 链接器的任务之一就是为函数调用找到匹配函数的可执行代码的位置（地址）。 x86-64的CPU包含一组16个存储64位值的通用目的寄存器，用于存放整数数据和指针。 操作数值。 最常用的寻址模式为比例变址寻址：$Imm(r_b, r_i, s) = M[Imm + R[r_b] + R[r_i] \\cdot s]$。 其他的寻址模式均为该寻址模式的特殊形式。 程序栈栈顶为小地址，栈底为大地址。 条件码寄存器，单个位（1bit），由CPU维护，描述了最近的算术或逻辑操作的属性，可以检测这些寄存器来执行条件分支指令。（程序状态字寄存器PSW、标志寄存器FR） CF：进位标志 ZF：零标志 SF：符号标志 —— 最近的操作得到的结果为负数。 OF：溢出标志 —— 最近的操作导致补码正负溢出。 PC中保存的为下一条指令的地址。 实现条件操作的传统方式为通过使用控制的条件跳转。当条件满足时，程序沿着一条执行路径执行，当条件不满足时，就走另一条路径。这种机制简单而通用，但是在现代处理器上，它可能会非常低效。（分支预测逻辑） 另一种实现条件策略的方式是使用数据的条件传送。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足选择其中一个。（无需进行分支预测） 不是所有的条件表达式都可以使用条件传送来编译。 C语言指针运算。 int E[some number] 表达式 类型 值 E int * $x_E$ E[0] int M[$x_E$] E[i] int M[$x_E$ + 4] \u0026E[2] int * $x_E$ + 8 E + i - 1 int * $x_E$ + 4i - 4 *(E + i - 3) int M[$x_E$ + 4i - 12] \u0026E[i] - E long i 可以看到C有一个神奇的特性，就是当两个指针相减时，得到的数据类型为long，值为两地址差除以指针所指数据类型长度。 /* arrptr.c */ #include \u003cstdio.h\u003e void main() { int e[10]; int i = 2; printf(\"e: %p\\n\", e); printf(\"\u0026e[%d]: %p\\n\", i, \u0026e[i]); printf(\"\u0026e[%d] - e: %ld\\n\", i, \u0026e[i] - e); // 相减得到数据类型为long，使用%ld输出。如果使用%p编译器会报错。 } gcc -o arrptr.out arrptr.c # gcc编译 ./test.out # 查看输出 # 输出 \u003e e: 0x7fffef9ea770 \u003e \u0026e[2]: 0x7fffef9ea778 \u003e \u0026e[2] - e: 2 可以看到差并不相等。 数组的嵌套。 int A[5][3]; typedef int row3_t[3]; // 上下两种定义方式等价 row3_t A[5]; 异质的数据结构。 C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制：结构（structure），用关键字struct声明，将多个对象集合到一个单位中；联合（union），用关键字union声明，允许用几种不同的类型来引用一个对象。 联合总的大小等于其最大字段的大小。 计算机系统对基本数据类型的合法地址作了一些限制，要求某种类型对象的地址必须是某个值K的倍数。称为数据对齐限制。数据对齐限制简化了接口设计，提高内存系统的性能。对齐的原则是任何K字节的基本对象的地址必须是K的倍数。 缓冲区溢出（buffer overflow）。 C对于数组引用不进行任何边界检查，对越界数组的写操作会破坏存储在运行时栈中的状态信息。 /* echo.c */ #include \u003cstdio.h\u003e char *getchars(char *s) { int c; char *dest = s; while ((c = getchar()) != '\\n' \u0026\u0026 c != EOF) *dest++ = c; if (c == EOF \u0026\u0026 s == dest) return NULL; *dest++ = '\\0'; return s; } void putchars(char *s) { while (*s != '\\0') printf(\"%c\", *s++); printf(\"\\n\"); } void echo() { char buf[1]; /* Way too small! */ getchars(buf); putchars(buf); } void main() { echo(); } gcc -o echo.out echo.c ./echo.out # Input \u003e 123 # Output \u003e 123 \u003e *** stack smashing detected ***: terminated \u003e Aborted (core dumped) 补记：C语言中单双引号的区别 单引号表示单个字符，要求字符数量只能为1，表示字符常量 双引号表示0到多个字符，表示字符串常量 蠕虫和病毒。 蠕虫和病毒都试图在计算机中传播它们自己的代码段 蠕虫（worm）可以自己运行，并且能够将自己的等效副本传播到其它机器 病毒（vrius）能将自己添加到包括操作系统在内的其他程序中，但它不能独立运行 ","date":"2022-06-10","objectID":"/csapp/:3:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 4 ISA 一个处理器支持的指令和指令的字节级编码称之为他的指令集体系结构（Instuction-Set Architecture, ISA）。ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层，编译器编写者只需要知道允许哪些指令，以及它们是如何编码的；而处理器设计者必须建造出执行这些指令的处理器。 “复杂指令集计算机”（CISC）\u0026“精简指令集计算机”（RISC） CISC 早期的RISC 指令数量很多。Intel描述全套指令的文档有1200多页。 指令数量少的多。通常少于100个。 有些指令的延迟很长。包括将一整块从内存的一个部分复制到另一部分的指令，以及其他一些将多个寄存器的值复制到内存或从内存复制到多个寄存器的指令。 没有较长延迟的指令。有些早期的RISC机器甚至没有整数乘法指令，要求编译器通过一系列加法来实现乘法。 编码长度是可变的。x86_64的指令长度可以是1～15个字节。 编码是固定长度的。通常所有的指令都编码为4个字节。 指定操作数的方式多种多样。x86_64中，内存操作数指示符可以有许多不同的组合，这些组合由偏移量、基址和变址寄存器以及伸缩因子组成。 简单寻址方式。通常只有基址和偏移量寻址。 可以对内存和寄存器操作数进行算术和逻辑运算。 只能对寄存器操作数进行算术运算和逻辑运算。允许使用内存引用的只有load和store指令。load指令是从内存读到寄存器，store是从寄存器写到内存。这种方法称之为load/store结构。 对机器级程序来说实现细节是不可见的。ISA提供程序和如何执行程序之间的清晰的抽象。 对机器级程序来说实现细节是可见的。有些RISC机器禁止某些特殊的指令序列，而有些跳转需要到下一条指令执行完才会生效。编译器必须在这些约束条件下进行性能优化。 有条件码，作为指令执行的副产品，设置了一些特殊的标志位，可以用于条件分支检测。 没有条件码。相反，对条件检测来说，要用明确的测试指令，这些指令会将测试结果放在一个普通的寄存器中。 栈密集的过程链接。栈被用来存储过程参数和返回地址。 寄存器密集的过程链接。寄存器被用来存取过程参数和返回地址。因此有些过程能完全避免内存引用。通常处理器包含更多的寄存器。 相邻指令间存在的相关。 数据相关（data dependency）：下一条指令会用到这一条指令计算的结果。 控制相关（control dependecny）：一条指令要确定下一条指令的位置，例如跳转、调用或是返回指令时。 冒险是指相关导致流水线产生计算错误。有数据冒险（data hazard）和控制冒险（control hazard）两种形式。 避免数据冒险。 暂停（stalling）。 数据转发（data forwarding），简称转发，又称旁路（passby）。 避免控制冒险。控制冒险只发生在ret和跳转指令上。发现错误指令，向错误指令中插入气泡，同时取出正确的指令，称为指令排除（instruction squashing）。 流水线设计的CPI（Cycles Per Instruction，每指令周期）的测量值不可能小于1.0。较新的处理器支持超标量（superscalar）的操作，意味着它们通过并行地取址、译码和执行多条指令，可以实现小于1.0的CPI。 ","date":"2022-06-10","objectID":"/csapp/:4:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter5 程序员必须写出清晰简洁的代码，这样做不仅是为了自己能够看懂代码，也是为了在检查代码和今后需要修改代码时，其他人能够读懂和理解代码。 妨碍优化的因素 内存中两个指针指向同一个内存的位置的情况称为内存别名使用（memory aliasing）。内存别名使用是妨碍编译器优化的主要因素。 void twiddle1(long *xp, long *yp) { *xp += *yp; *xp += *yp; } void twiddle2(long *xp, long *yp) { *xp += 2 * *xp; } 可以看到twiddle2函数相较于twiddle1函数有着更少次数的内存引用。但是当*xp与*yp指向相同位置时，两函数会带来不同的结果。 函数调用。 long counter = 0; long f() { return counter++; } long func1() { return f() + f() + f() + f(); } long func2() { return 4 * f(); } 可以看到func2相较于func1有着更少次数的函数调用。但是对于程序中给定的f()，由于两函数对f()的调用次数不同，因此最后的结果也不同。 循环展开（loop unrolling）技术。在循环中，每次迭代计算两个元素。 前置和（prefix sum）: $$ p_0 = a_0 \\ p_i = p_{i - 1} + a_i, 1 \\le i \u003c n \\ $$ /* Compute preifx sum of vector a */ void psum1(float a[], float p[], long n) { long i; p[0] = a[0]; for (i = 1; i \u003c n; i++) { p[i + 1] = p[i] + a[i]; } } void psum2(float2 a[], float p[], long n) { long i; p[0] = a[0]; for (i = 1; i \u003c n - 1; n += 2) { float mid_val = p[i - 1] + a[i]; p[i] = mid_val; p[i + 1] = mid_val + a[i + 1]; } /* For even n, finish remaining element */ if (i \u003c n) p[i] = p[i - 1] + a[i]; } 循环展开可以使用更少的循环次数完成计算，减少计算的时间。 最小二乘拟合 对于一个数据点$(x_1, y_1), (x_2, y_2), …, (x_n, y_n)$的集合，使用最小二乘拟合，寻找一条形如$y=mx+b$的线，使得下面这个误差度量最小： $$ E(m,b)= \\sum_{i=1}^{n}(mx_i+b-y_i)^2 $$ 将$E(m,b)$分别对$m$和$b$进行求导，把两个函数的导数设为0,进行推导即可的出结果。 结构体的点运算符（.）和箭头运算符（-\u003e）。 点运算符用于结构体对象访问其成员，而箭头运算符用于结构体对象的指针访问其成员。 struct student { char Name[10]; short age; } stu, *pstu; short age = stu.age; short age = pstu -\u003e age; 内存分配函数。 malloc void *malloc(size_t size); 参数： size - 元素的大小 该函数返回一个指针 ，指向已分配大小的内存。如果请求失败，则返回 NULL。 calloc void *calloc(size_t nitems, size_t size); 参数： nitems - 要被分配的元素个数 size - 元素的大小 该函数返回一个指针，指向已分配的内存。如果请求失败，则返回 NULL。与malloc之间的不同是，malloc不会设置内存为0，而calloc会设置内存为0。 程序性能提升 原始代码。 #include \u003cstdlib.h\u003e #define IDENT 0 #define OP + typedef long data_t; /* Create abstract data type for vector */ typedef struct { long len; data_t *data; } vec_rec, *vec_ptr; /* Create vector of specified length */ vec_ptr new_vec(long len) { /* Allocate header strcuture */ vec_ptr result = (vec_ptr) malloc(sizeof(vec_rec)); data_t *data = NULL; if (!result) return NULL; /* Couldn't allocate storage */ result -\u003e len = len; /* Allocate array */ if (len \u003e 0) { data = (data_t *) calloc(len, sizeof(data_t)); if (!data) { free((void *) result); return NULL; /* Couldn't allocate storage */ } } /* Data will either be NULL or allocated array */ result -\u003e data = data; return result; } /* * Retrieve vector element and store at dest. * Return 0 (out of bound) or 1 (successful) */ int get_vec_element(vec_ptr v, long index, data_t *dest) { if (index \u003c 0 || index \u003e= v -\u003e len) return 0; *dest = v -\u003e data[index]; return 1; } /* Return length of vector */ long vec_length(vec_ptr v) { return v -\u003e len; } /* Implementation with maximum use of data abstraction */ void combine1(vec_ptr v, data_t *dest) { long i; *dest = IDENT; for (i = 0; i \u003c vec_length(v); i++) { data_t val; get_vec_element(v, i, \u0026val); *dest = *dest OP val; } } 代码移动，消除循环的低效率 /* Move call to vec_length out of loop */ void combine2(vec_ptr v, data_t *dest) { long i; long length = vec_length(v); for (i = 0; i \u003c length; i++) { data_t val; get_vec_element(v, i, \u0026val); *dest = *dest OP val; } } 将函数调用移出循环，提高循环效率。 循环中的渐进低效率： /* Convert string to lowercase: slow */ void lower1(char *s) { long i; for (i = 1; i \u003c strlen(s); i++) { if (s[i] \u003e= 'A' \u0026\u0026 s[i] \u003c= 'Z') s[i] -= ('A' - 'a'); } } /* Convert string to lowercase: faster */ void lower2(char *s) { long i; long len = strlen(s); for (i = 0; i \u003c len; i++) { if (s[i] \u003e= 'A' \u0026\u0026 s[i] \u003c= 'Z') s[i] -= ('A' - 'z') } } /* Sample implementation of library function strlen */ /* Compute length of string */ size_t strlen(const char *s) { long length = 0; while (*s != '\\0') { s++; length++; } return length; } void mylower(char *s) { int dif = 'A' - 'a'; char *ptr; ptr = s;引用 while (*ptr != '\\0') { if (*ptr \u003e= 'A' \u0026\u0026 *ptr \u003c= 'Z') *ptr -= dif; ptr++; } } 减少过程调用。 data_t *get_vec_start(vec_ptr v) { return v -\u003e data; } /* Direct access to vector data */ void com","date":"2022-06-10","objectID":"/csapp/:5:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 6 存储器系统（memory system）是一个具有不同容量、成本和访问时间的存储设备的结构层次。 随机访问存储器（Random-Access Memory，RAM）。RAM断电后所有的信息都会消失。 静态RAM（SRAM） SRAM的工作原理是将位存储在一个双稳态（bistable）的存储器单元里，由于其双稳态特性，只要通电，它就会永远保持它的值，因此被称为静态RAM。 动态RAM（DRAM） DRAM将每个位存储为对一个电容的充电，有很多原因会导致电容的漏电，这就意味着DRAM需要周期性的刷新，因此被称为动态RAM。DRAM存储器单元对干扰十分敏感，暴露在光线下会导致电容改变，数码照相机和摄像机中传感器的本质就是DRAM单元的阵列。 \\ 每位晶体管数 相对访问时间 是否持续 是否对干扰敏感 相对花费 应用 SRAM 6 1x 是 否 1000x 高速缓存存储器 DRAM 1 10x 否 是 1x 主存、帧缓冲区 DRAM被组织成二维阵列，主要是为了降低芯片上地址引脚的数量，缺点是必须分两步发送地址，增加了访问时间。 非易失性存储器（nonvolatile memory），由于历史性原因，一般统称为只读存储器（Read-Only Memory，RAM）。 固件（firmware）。 存储在ROM中的程序通常被称为固件，当一个计算机系统通电以后，它会运行存储在ROM中的固件，例如PC的BIOS。 格式化的磁盘容量。 磁盘控制器必须对磁盘进行格式化，才能在磁盘上存储数据。格式化包括用标识扇区的信息填写扇区之间的空隙，标识出表面有故障的柱面而不使用它们，以及在每个区中预留出一组柱面作为备用。 例如图形卡、监视器、鼠标、键盘和磁盘这样的I/O设备，都是通过I/O总线，例如Intel的外围设备总线（Peripheral Component Interconnect，PCI）总线连接到CPU和主存的。 存储器结构的中心思想是，对于每一个K，位于第K层的更快更小的存储设备作为位于第K+1层的更大更慢的存储设备的缓存。在任何时刻，第K层的缓存包含第K+1层块的一个子集的副本。 缓存写。 写命中（write hit） 直写（write-through），立即将高速缓存块中的内容写进低一层中，缺点是每次写都会引起总线流量。 写回（write-back），当替换算法需要驱逐块时才进行写，缺点是提高了复杂性，需要维护一个额外的修改位（dirty bit）。 写不命中 写分配（write-allocate），加载低一层的块到高速缓存中，缺点是每次不命中都会导致块更新。 非写分配（not-write-allocate），直接写进低一层中。 直写高速缓存一般搭配非写分配，而写回高速缓存一般搭配写分配。 高速缓存即保存数据，也保存指令。只保存指令的称为i-cache，只保存数据的称为d-cache，既保存数据又保存指令的称为统一的高速缓存 （unified cache）。现代处理器一般包含独立的i-cache和d-cache，这样做使得处理器能够同时读一个指令字和一个数据字；并且i-cache通常是只读的，因此比较简单，可以针对不同的访问模式来优化这两个高速缓存。 ","date":"2022-06-10","objectID":"/csapp/:6:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 7 ELF文件格式。 ELF的英文全称是The Executable and Linking Format，最初是由UNIX系统实验室开发、发布的ABI(Application Binary Interface)接口的一部分，也是Linux的主要可执行文件格式。 ELF文件格式的种类： 可执行文件（.out）：Executable File，包含代码和数据，是可以直接运行的程序。其代码和数据都有固定的地址（或相对地址的偏移），系统可以根据这些地址信息把程序加载到内存执行。 可重定位文件（.o）：Relocatable File，包含基础代码和数据，但它的代码和数据都没有指定的绝对地址，因此适合于与其它目标文件链接来创建可执行文件或者共享目标文件。 共享目标文件（.so）：Shared Object File，也称动态库文件，包含了代码和数据，这些数据是在链接时被链接器（ld）和运行时动态链接器（ld.so.1、libc.so.1、ld-linux.so.1）使用的。 编译器驱动程序。 # gcc编译 gcc -Og -o prog main.c sum.c # 首先运行c预处理器cpp，将源程序（.c）翻译成ASCII码的中间文件（.i） cpp [other arguments] main.c /tmp/main.i # 接下来运行c编译器cc1，将.i文件翻译为ASCII汇编语言文件（.s） cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s # 然后，驱动程序运行汇编器as，将.s翻译成一个可重定位目标文件（relocatable object file）.o as [other arguments] -o /tmp/main.o /tmp/main.s # 最后，运行链接器程序ld，将main.o和sum.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件（Executable object file） ld -o prog [system object files and args] /tmp/sum.o /tmp/main.o 要执行可执行文件，直接在shell上输入它的名字，shell调用操作系统中一个叫做加载器的函数，将可执行文件中代码和数据复制到内存，然后将控制转移到这个程序的开头。 Linux ld程序为静态链接器（static linker），以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。 为了构造可执行文件，链接器必须完成两个主要任务： 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。 重定位（relocation）。编译器和汇编器生成地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得他们指向这个内存位置。链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位。 目标文件时按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。Windows使用可移植可执行格式（Portable Executable，PE）格式。MacOS-X使用Mach-O格式。现代x86-64 Linux和Unix系统使用可执行可连接格式（Executable and Linkable Fromat，ELF）。 至7.4节暂且跳过 ","date":"2022-06-10","objectID":"/csapp/:7:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 8 暂且跳过 ","date":"2022-06-10","objectID":"/csapp/:8:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 9 暂且跳过 ","date":"2022-06-10","objectID":"/csapp/:9:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["CS"],"content":"Chapter 10 Linux文件类型 普通文件（regular file）包含任意数据，又分为文本文件（text file）和二进制文件（binary file）。 目录（directory）是包含一组链接（link）的文件，其中每个链接都将一个文件名（filename）映射到一个文件，这个文件也可能是个目录。 套接字（stock）是用来与另一个进程进行跨网络通信的文件。 size_t无符号大小、ssize_t有符号大小。 一次一字节从标准输入复制到标准输出 #include \"csapp.h\" int main(void) { char c; while (Read(STDIN_FILENO, \u0026c, 1) != 0) Write(STDOUT_FILENO, \u0026c, 1); exit(0); } ","date":"2022-06-10","objectID":"/csapp/:10:0","tags":["CS","读书笔记"],"title":"CS:APP","uri":"/csapp/"},{"categories":["Linux"],"content":"Linux只要花点功夫配置好就会很好用？","date":"2022-06-09","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux%E4%B9%8Bwine%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E5%BC%8F/","tags":["Linux","Wine","编码"],"title":"优雅地使用Linux之Wine的食用方式","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux%E4%B9%8Bwine%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["Linux"],"content":" 补记 最近（2022.9.26）安装了Feodra系统，发现这篇文章实在是没什么用处；对于不同的操作系统，wine的安装方式直接参考winehq的wiki即可。对于Ubuntu、Debian系统来说，还可以配置TUNA的镜像，加速安装。对于Fedora用户，很遗憾只能自行配置代理；具体操作为修改/etc/yum.repos.d/winehq.repo，在最后一行添加proxy=\"XXXXXX\"之后再运行dnf makecache等命令。 wine在首次运行程序之前，需要先运行winecfg命令来生成配置文件。 解决安装问题之后，如果使用中文环境，那么还可能会遇到中文全部方框的问题。这是因为没有安装中文字体导致的。比较方便的解决方式有两种，一是使用winetricks安装字体，受制于网络的限制，这种方式常常面临着失败；另一种较为快捷的方式就是打开安装了中文的Windows系统，并将C:\\windows\\Fonts目录下的字体复制到~/.wine/drive_c/windows/Fonts文件夹下，通常可以解决文字方框的问题。 对于wine的中文乱码问题，如正文所说是字符集的问题。如果我们的操作系统设置的语言为英文，那么在运行wine cmd之后使用chcp命令检查会得到437，即英文环境；而当我们使用env LC_ALL=zh_CN.UTF-8 wine cmd，即设置环境为中文环境并启动cmd，此时检查chcp得到的代码为65001，也就是使用了UTF-8编码，在这种情况下，基本可以解决所有的乱码问题。 还有一类导致无法运行程序的错误是系统缺少某些驱动，然而缺少驱动的报错信息在双击运行exe的报错中是没有的，这时最好的方式应该是使用wine xxx.exe来启动程序，在命令行中检查即可发现缺少的驱动报报错等信息。 很多时候，你不得不运行一些Windows可执行程序，但是苦于手头仅有一台Linux设备，你或许想要使用虚拟机，不巧的是你又讨厌虚拟机那种令人厌烦的卡顿、不跟手的感觉，那么Wine，就是为你量身定制的！Wine全称Wine Is Not an Emulator（Wine不是一个模拟器），是一个能在Linux系统上运行Windows应用的兼容层。简单来说，只要安装了Wine，就可以简单的在Linux系统上通过双击exe文件来运行这些可执行程序！但是呢，Wine的安装与使用还有一些小坑，在这里简单记录一下这些坑以及Wine的最佳食用方式。 最简单的方法莫过于apt安装，即简单的输入： sudo apt-get install wine 但是这种最简单的安装方式有着一个致命的缺陷，那就是版本太老了。以本文写成的时间为例，最新版本的Wine已经更新到了7.10，然而apt还只能安装6.X版本的Wine。并且6.X版本的Wine对Direct的支持还有待提高，很多基于Direct游戏不能正常的在Linux系统上运行。那么似乎下一步就是自行编译最新版本的Wine了。在编译之前首先应当卸载当前的Wine。 sudo apt-get remove wine 卸载Wine之后，摸到Wine的官网，在这里提供两个下载选项，分别是稳定版的7.0版本和开发版的7.10。下载自己所需要的版本，解压后即可运行： ./configure make 来对Wine进行一个简单的安装。当然，在这个过程中会被提示缺少各种各样的依赖，但总之是可以凭借着毅力解决的！这里不再记录解决过程，因为这是一个非常麻烦并且不推荐的安装方式。事实上，当我费尽九牛二虎之力，我的垃圾笔电也编译了一个多小时之后，终于安装好Wine。自以为可以愉快体验一个Windows游戏而洋洋得意时，很讨厌的是，游戏进去是进去了，但是完完全全就是一个黑屏，经排查除了游戏之外的一些小程序可以正常运行。事实上问题的原因我现在还没有搞清楚，当时使用的版本是稳定版7.0版本，各种无头苍蝇一样的debug方式尝试过之后，只好将最后的希望放在Wine开发版上。说来也是巧合，当我在Wine官网苦苦寻找解决办法无果，却偶然发现，就在官网上就清清楚楚的写着，Wine安装的最佳方式！以Ubuntu22.04系统举例，安装方式如下： # 开启32bit架构支持 sudo dpkg --add-arrchitecture i386 # 下载添加仓库密钥 wget -nc https://dl.winehq.org/wine-builds/winehq.key sudo mv winehq.key /usr/share/keyrings/winehq-archive.key # 添加仓库 wget -nc https://dl.winehq.org/wine-builds/ubuntu/dists/jammy/winehq-jammy.sources sudo mv winehq-jammy.sources /etc/apt/sources.list.d/ # 更新安装包 sudo apt-get update # 安装开发分支的Wine sudo apt install --install-recommends winehq-devel 就这样，轻而易举的解决了安装过程中的依赖问题和编译耗时，并且在安装了开发分支的Wine7.10之后，游戏终于运行了起来！可谓： 踏破铁鞋无觅处，得来全不费功夫！ 但是呢，人生总是这么跌宕起伏，游戏进去了，但是却又碰到了闪退的问题。经排查，发现游戏存档文件夹出现了乱码情况，初步怀疑是游戏存档文件夹为中文导致的编码问题。使用中文环境启动游戏： env LANG=zh_CN.UTF-8 wine game.exe 发现成功读取了游戏文件夹，确定为编码问题。修改编码问题最简单的方式为在~/.bashrc中添加export LANG=zh_CN.UTF_8，这样，当以当前用户使用Terminal启动游戏时，游戏可以正常显示中文。但是当双击游戏文件启动时，依旧不能正常显示中文。为了解决这个问题，经搜索，需要修改默认的环境配置，配置文件夹位于/etc/profile，需要在最后一样添加LANG=zh_CN.UTF_8即可修改默认编码为中文的UTF-8编码，十分的方便。 后记：啰啰嗦唆没用的话 毕业终于完事了，没少费功夫，最后终于是拿到了毕业证，和大家伙也天各一方。毕业离开学校的那天，头一次喝醉吐的自己浑身都是，可能我自己心里是非常喜欢大家伙的吧，我也不知道。离别总是酸楚，但是回到家乡，离开校园，还是得直面困难的。现在隔离在宾馆，天天闲的难受，这样的日子，今天也是最后一晚了。和我一样二战的家伙已经开始规律作息好好复习了，我也不能拉了胯，考前最后一次熬夜！！！再也不熬夜了！最后就是，果然还是好好的把自己心中所想表达出来能让人心情舒畅。 ","date":"2022-06-09","objectID":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux%E4%B9%8Bwine%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E5%BC%8F/:0:0","tags":["Linux","Wine","编码"],"title":"优雅地使用Linux之Wine的食用方式","uri":"/%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8linux%E4%B9%8Bwine%E7%9A%84%E9%A3%9F%E7%94%A8%E6%96%B9%E5%BC%8F/"},{"categories":["AI"],"content":" 注意 论文初稿，主要阐述了研究方向、技术路线及研究结果。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:0:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"摘要 本研究以辽宁省及其周边为研究区域，引入人工智能模型，通过捕获大气颗粒物污染的历史时空间浓度分布、地理环境和大气信息，用以预测未来的大气颗粒物空间分布情况，并将预测结果与基于WRF-Chem模型的预测结果进行比较，试图构建更准确的模型，做到更为快速及时的大气颗粒污染物预测响应。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:1:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"绪论 良好生态环境是实现中华民族永续发展的内在要求，是增进民生福祉的优先领域，是建设美丽中国的重要基础。随着我国可持续发展理念认知的不断深入，在大力开展经济建设的同时，生态文明建设也日益加强。环境污染的防治成为国家发展建设中的一项重要工作，其中的大气污染防治更是重中之重。2021年11月，国务院发布了关于深入打好污染防治攻坚战的意见，其中明确提到，要深入打好蓝天保卫战，为我国的大气污染防治工作提出了更高的要求1。 在众多大气环境污染问题之中，以颗粒物（$PM_{2.5}$ 、$PM_{10}$）污染是现阶段我国面临的最主要大气环境污染问题。《2020年中国生态环境状况公报》2显示，全国337个地级及以上城市中，以$PM_{2.5}$为首要污染物的超标天数（空气质量指数（AQI）大于100的天数）占到了总超标天数的51.0%。大气颗粒污染物对人体健康、大气能见度及气候变化都有着重要的影响，已经受到了公众的广泛关注，并且成为了近年来学术界的研究热点。相关研究表明，$PM_{2.5}$与死亡率以及心肺疾病住院率密切相关3；以$PM_{2.5}$为主的户外空气污染，导致全世界每年330万（95%的置信区间）人的过早死亡4。为确保我国经济的可持续发展，坚决打赢蓝天保卫战，大气颗粒物污染的治理是重中之重。 为了减少大气颗粒物污染对生态环境、人类健康和社会经济带来的危害，制定合理有效的污染防治策略，有必要把握空气中颗粒物形成和扩散的动态过程，并对颗粒物浓度空间分布做出相对准确的预测。空气质量预报模型可以预估大气污染变化趋势，同时对大气污染过程、污染物来源解析以及区域输送过程进行及时分析，从而提高城市预报预警能力以及污染物溯源能力。短期的空气质量预测可以协助公众及时响应高污染事件，做好相应的防护措施5；长期的空气质量预测则可以为相关部门大气污染联防联控提供准确及时的大气污染信息，提高污染管控能力，减少社会经济损失6。了解大气污染过程以及大气污染状况，建立准确的空气质量预报模型，可以向大气颗粒物污染治理提供更加合理的决策支持。 空气质量模型，按照机理划分，可以分为数值模型和统计模型两种。空气质量数值模型通过对污染物在空气中发生的物理化学过程（如传输、扩散、化学反应等）进行数学抽象而建立7，根据大气的实际情况，在一定的初值和边界条件下对大气污染的物理化学过程进行仿真，从而预测未来一段时间内大气污染物的浓度分布情况。常用的空气质量模型如：CALPUFF8、WRF-Chem9、CMAQ10等模型都属于数值模型。数值模型可解释性强，但是存在3个主要问题：（1）大气边界层模拟引起的不确定性；（2）大气污染物排放源引起的不确定性；（3）大气物理化学过程引起的不确定性。这3个主要问题大大限制了空气质量模型的模拟精度11。 统计模型以现有的大量数据为基础，通过对数据进行统计分析，建立空气质量模型7。以$PM_{10}$预测统计模型为为例，常用的建模算法有：人工神经网络（Artificial Neural Networks， ANN）、多变量线性回归（Multi-variate Linear Regression，MLR）、多层感知机（Multi Layer Perceptron，MLP）、支持向量机（Support Vector Machines，SVM）等12，这些建模算法都隶属于机器学习（Machine Learning，ML）的范畴。机器学习是一类强大的可以从经验中学习的技术，通常采用观测数据或与环境交互的方式，机器学习算法会积累更多的经验，其性能也会逐步提高13。在数值模型的3个主要问题中，问题（1）和问题（3）主要由当前对大气物理化学过程理解不充分而导致的建模不准确引起11。统计模型的建立依赖于观测得到的数据，而并不依赖于大气物理化学理论的进展，因此统计模型可以有效地弥补数值模型的缺陷。 深度学习（Deep Learning，DL）是机器学习的一个分支，通过层次化，使计算机构建较为简单的概念，并将简单概念组合来学习复杂概念。自深度学习这个术语在2006年被正式提出后，在最近10多年得到了巨大发展，它使人工智能（Artificial Intelligence，AI）产生了革命性的突破14，也大大推进了空气质量统计模型的发展，相关工作层出不穷。2015年，尹文君等将深度置信网络15（Deep Belief Network，DBN）运用到了空气质量预测上，将过去一天空气污染情况、过去一天和预报的污染物扩散条件作为神经网络的输入来预测预报污染物的浓度，相较经典的机器学习预报模型，DBN模型性能更好16。其弊端也显而易见：对于统计模型来说，空气质量预测问题作为一种典型的时空序列预测问题，强烈依赖于历史数据所提供时间和空间上的信息，而该模型不仅没有考虑空间内大气物理化学因素的影响，在时间上也只能处理过去一天的平均污染物浓度而忽略了时间序列上的其它信息。2017年，Xiang Li等人利用长短期记忆17（Long Short-Term Memory，LSTM）神经网络，提出了一种基于历史大气污染浓度和气象数据建立的$PM_{2.5}$浓度预测模型18。该模型能对具有长时间依赖性的时间序列进行建模，充分考虑了时间序列上的信息，但空间内信息依旧考虑不足。2021年，黄伟建等提出了时间序列记忆网络（Time Series Memory Network，TSMN）模型。该模型使用门控循环单元19（Gated Recurrent Unit，GRU）和卷积神经网络20（Convolutional Neural Network，CNN），构建了处理时间信息的本地记忆组件和处理空间信息的邻域组件，并结合通过全连接层（Fully Connected Layer，FC）整合两组件提取到的时空特征，获得目标站点未来24小时的$PM_{2.5}$ 浓度预测值。尽管TSMN模型整合了时间信息和空间信息，但该模型仅能给出目标站点处$PM_{2.5}$的预测浓度，与可以给出污染物空间浓度分布预测的WRF-Chem、CMAQ等数值模型相比仍有差距。 在深度学习领域，将预测给定视频帧的未来帧的任务称为视频预测21（Video Prediction）任务，早在2015年，视频预测这个概念就已经被提出22。通过将雷达图视为视频帧，Xingjian Shi等提出了卷积长短期记忆（Convolutional Long Short-Term Memory，Conv-LSTM）模型用于预测降水强度23。Conv-LSTM模型兼顾了CNN在提取空间信息上的优势和LSTM在提取时间信息上的优势，以过去数帧雷达回波图作为输入，预测未来的雷达回波图，从而推断出空间范围内的降水强度。2020年，张迪等通过运行WRF气象模型和CMAQ空气质量数值模型得到的中国地区细颗粒物空间浓度分布数据作为Conv-LSTM模型的训练数据，构建了基于深度学习的大气细颗粒物时空预报模型24。与其它基于深度学习的空气质量预报模型相比，Conv-LSTM模型可以给出污染物浓度的空间分布，而与CMAQ等数值模型相比，Conv-LSTM模型又有着预测速度快，资源消耗少的优点。近年来深度学习发展迅速，距Conv-LSTM提出至今7年以来，针对视频预测任务的深度学习模型不断更新，预测精度与预测速度等多方面都有所显著改善25。将更有效的模型运用到大气颗粒物污染浓度预测模型的构建上势在必得。 本文综合考虑我国大气污染问题和空气质量模型研究领域现状，有针对性地展开研究。本研究以辽宁省及其周边区域为研究区域，以大气颗粒物为研究对象，引入深度学习模型，使用数值模型WRF-Chem的输出数据作为训练数据，尝试使模型捕获模型内部的大气物理化学过程模式来构建基于人工智能的大气颗粒污染物扩散模拟模型。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:2:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"研究方法 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:3:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"数据准备 数据于空气质量模型是非常重要的。对于数值模型而言，原始数据作为数值模拟的初始和边界条件，允许模型计算求解通过数学抽象污染物输送、扩散、化学转化等大气过程得到的方程组来预测大气污染物的浓度分布7。对于统计模型来说，建立模型本身就依赖于对原始数据的统计与分析，以统计模型中广泛应用的机器学习算法为例，机器学习算法通过从原始数据中提取模式来不断提高自身的性能14，因此原始数据的质量与模型最终的性能密切相关。同时，深度学习算法对数据量也有着较高的需求，统计估计的一大问题就是泛化（generalization）问题，泛化指的是训练好的模型在前所未见的数据上性能的好坏，而增加数据量可以有效提高模型的泛化能力。因此，为构建基于深度学习的大气颗粒物污染浓度预测模型，大量且准确的数据是必要的。然而，真实环境下的历史数据难以取得，主要原因是真实环境下的大气污染物浓度数据多为监测站点处浓度，是时间维度上的一维变量，而为了对大气颗粒物空间浓度分布进行统计预测，需要时间维度和空间维度组合的三维变量。为此，本研究选择WRF-Chem空气质量模型输出的WRFOut数据作为深度学习模型的训练数据。 本研究采用的WRFOut数据共三段，分别是2018年1月25日00:00到2018年1月27日07:00的逐小时数据55条（数据段1）、2019年1月10日00:00到2019年1月13日15:00的逐小时数据87条（数据段2）及2019年2月26日00:00到2019年3月1日08:00的逐小时数据79条（数据段3）。这三段数据的模拟范围均采用兰伯特投影坐标系，中心经纬线为北纬41.75°和东经123.53°，即以沈阳市为中心。模拟网格分辨率为27千米$\\times$27千米，网格数量为90$\\times$90共8100格。模拟范围见下图。 WRFOut数据以网络通用数据格式26（Network Common Data Form，NetCDF）存储，使用Python编程语言下的netcdf4-python27库读取WRFOut数据。NetCDF格式的数据以变量（variable）为单位进行保存，每个变量都有变量描述、变量单位、变量形状、变量值等多个属性。对于WRF-Chem模拟导出的WRFOut数据，其中包含了时间（Times）、经度（XLONG）、维度（XLAT）等时空间位置描述性变量；X轴风速分量（U），雨水混合率（QRAIN）等气象数据；土壤温度（TSLB）、土壤液态水（SH2O）等地理数据；$SO_{2}$混合比（so2）、PAN混合比（pan）等污染物浓度数据以及积聚核模人为源芳香烃二次有机气溶胶浓度（orgaro1j）等污染物排放数据共计281个变量。若将变量全部用于神经网络的训练，则模型对内存的要求将大大超出可接受范围，为此，需要从变量中筛选出对大气颗粒物影响较大的变量以减少硬件压力。以变量形状、变量值以及变量描述为依据，最终选出30个变量作为神经网络训练的输入变量，详见下表。 变量关键字 变量描述 变量单位 PM10 $PM_{10}$干质量 $ug/m^{3}$ PM2_5_DRY $PM_{2.5}$气溶胶干质量 $ug/m^{3}$ U X轴风速分量 m/s V Y轴风速分量 m/s QVAPOR 水汽混合比 kg/kg CLDFRA 云量 % so2 $SO_{2}$混合比 ppmv no2 $NO_{2}$混合比 ppmv no NO混合比 ppmv so4aj 积聚核膜硫酸盐浓度 ug/kg干空气 so4ai 爱根核模硫酸盐浓度 ug/kg干空气 nh4aj 积聚核膜铵盐浓度 ug/kg干空气 nh4ai 爱根核模铵盐浓度 ug/kg干空气 no3aj 积聚核膜硝酸盐浓度 ug/kg干空气 no3ai 爱根核模硝酸盐浓度 ug/kg干空气 orgaro1j 积聚核模人为源芳香烃二次有机气溶胶浓度* ug/kg干空气 orgaro1i 爱根核模人为源芳香烃二次有机气溶胶浓度* ug/kg干空气 orgaro2j 积聚核模人为源芳香烃二次有机气溶胶浓度* ug/kg干空气 orgaro2i 爱根核模人为源芳香烃二次有机气溶胶浓度* ug/kg干空气 orgalk1j 积聚核模人为源除芳香烃外烷烃二次有机气溶胶浓度* ug/kg干空气 orgalk1i 爱根核模人为源除芳香烃外烷烃二次有机气溶胶浓度* ug/kg干空气 orgole1j 积聚核模人为源除芳香烃外烷烃二次有机气溶胶浓度* ug/kg干空气 orgole1i 爱根核模人为源除芳香烃外烷烃二次有机气溶胶浓度* ug/kg干空气 orgpaj 积聚核模人为源芳香烃一次有机气溶胶浓度 ug/kg干空气 orgpai 爱根核模人为源芳香烃一次有机气溶胶浓度 ug/kg干空气 ecj 积聚核膜元素碳 ug/kg干空气 eci 爱根核模元素碳 ug/kg干空气 p25j 积聚核膜一次$PM_{2.5}$ ug/kg干空气 p25i 爱根核模一次$PM_{2.5}$ ug/kg干空气 antha 人为源粗气溶胶 ug/kg干空气 *虽然描述相同，但并不是重复的数据。这是因为WRF-Chem运行时采用的排放清单对不同来源的人为源做了区分（如交通排放、生产排放等），但未对变量描述做对应的区分，仅修改了变量关键字。 为了简化操作，需要将NetCDF格式的数据重新打包为npy格式。NumPy28（Numerical Python）是Python常用的矩阵运算拓展库，而npy格式是NumPy专用的二进制格式。与NetCDF格式相比，npy格式的文件以矩阵为单位组织数据，仅保存变量值而忽略了变量描述、变量单位等其他信息，大大降低了变量值操作复杂度，便于神经网络的训练。经NumPy重新组织的变量值为一个4维矩阵数据，4个维度分别为：时间、变量、X轴、Y轴。在神经网络训练前，需要将数据划分为训练集和和测试集，一般训练集和测试集数据量比为8:2，但是为了保证数据时间上的连续性，本研究将数据量较多的数据段2和数据段3划分为训练集，并以npy格式保存。训练集矩阵形状为（166，30，90，90），其中166代表数据段2和数据段3共166条逐小时数据，30代表经筛选的神经网络输入变量共30个，（90，90）代表WRF-Chem模拟网格数量为90$\\times$90。同时将数据量较少的数据段1划分为测试集并以npy格式保存，测试集矩阵形状为（55，30，90，90）。至此，神经网络模型训练数据准备阶段完毕。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:3:1","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"模型构建 构造大气颗粒物浓度预测模型的目标是：给定先前观测到气象、污染物排放等数据的时间序列，来预测下一个时间点处大气颗粒物浓度的空间分布。以机器学习的观点来看，这个问题可以归结为时空间序列预测问题。假设某动态系统在一个以$M \\times N$网格表示的空间区域内被观测，在每个网格内，动态系统的状态都可以通过$L$个变量来描述，那么任何时刻的该系统整体的状态都可以通过一个矩阵$\\mathcal{X} \\in R^{L \\times M \\times N}$来表示，其中$R$代表被观测特征的范围.每次对该动态系统进行观测，都可以得到观测时刻$t$的系统状态$\\mathcal{X_{t}}$。时空序列预测问题就是根据包含当前时刻在内的$K$个先前的观测得到的系统状态$\\hat{\\mathcal{X_{t-K+1}}},\\hat{\\mathcal{X_{t-K+2}}},…,\\hat{\\mathcal{X_{t}}}$，来预测未来最可能的系统状态$\\tilde{\\mathcal{X_{t+1}}}$，即： $$ \\tilde{\\mathcal{X_{t+1}}} = \\mathop{\\arg\\max}\\limits_{\\mathcal{X_{t+1}} \\in R^{L \\times M \\times N} } \\ {P(\\mathcal{X_{t+1}} \\mathcal{|} \\hat{\\mathcal{X_{t-K+1}}},\\hat{\\mathcal{X_{t-K+2}}},…,\\hat{\\mathcal{X_{t}}})} $$ 对于时空间序列预测问题而言，为解决这一类问题而构建的神经网络模型可以通过函数$y=f(x;\\theta)$表示。其中$f$表示神经网络的架构、$\\theta$表示神经网络的参数、$x$，$y$分别表示网络的输入和输出，即： $$ \\tilde{\\mathcal{X_{t+1}}}=f(\\hat{\\mathcal{X_{t-K+1}}},\\hat{\\mathcal{X_{t-K+2}}},…,\\hat{\\mathcal{X_{t}}};\\theta) $$ 当模型架构$f$给定后，神经网络通过$\\theta$定义了条件分布$\\tilde{P}(y|x ; \\theta)$。神经网络训练，或称模型优化，就是指通过调整$\\theta$使得模型定义的条件概率分布$\\tilde{P}$与尽可能逼近真实环境下的条件概率分布$\\hat{P}$的过程。为了达到这一目的，一般需要定义一个代价函数$L(\\tilde{y},\\hat{y};\\theta)$，通过计算得到的代价值来衡量当前神经网络预测的结果$\\tilde{y}$与观测结果$\\hat{y}$之间的差距，并寻找一个最小化所有观测得到$n$个样本上总损失的参数$\\theta^{\\ast}$，这个过程可以以表示为： $$ \\theta^{\\ast} = \\mathop{\\arg\\min}\\limits_{\\theta} \\ {\\frac{1}{n} \\sum^{n}_{i=0} L(\\tilde{y}^{(i)},\\hat{y}^{(i)};\\theta)} $$ 综上所述，为构造基于深度学习的大气颗粒物浓度预测模型，需要讨论模型架构和模型优化两个问题。 模型架构 架构（Architecture）一词指的是神经网络整体的结构，即网络应该由多少个单元组成，以及这些单元之间的连接方式。讨论模型架构问题，就是要找到适合当前任务所需要的架构。 大多数神经网络被组织成称为层的单元组。大多数神经网络架构将这些层布置成链式结构，其中每一层都是前一层的函数。在这种结构中，第一层由下式给出： $$ h^{(1)} = \\sigma^{(1)}(f^{(1)}(x;\\theta^{(1)})) $$ 第二层由 $$ h^{(2)}=\\sigma^{(2)}(f^{(2)}(h^{(1)};\\theta^{(2)})) $$ 给出，以此类推。其中$f^{(1)}$和$f^{(2)}$代表某种运算，如矩阵乘法、卷积（Convolution）运算等；$\\sigma^{(1)}$和$\\sigma^{(2)}$被称为激活函数（Activation Function），用于将非线性特性引入到神经网络中，使神经网络拥有学习非线性函数的能力。在这种链式架构中，架构主要考虑的是网络的深度和每一层的宽度。网络的深度一般指链式架构的长度，每一层的宽度则代表了该层参数的数量，宽度越宽，则参数量越大。一般而言，增加参数量可以提高网络的表示能力，增加网络的深度可以使网络更容易泛化到测试集。对于一个具体的任务，理想的网络架构必须通过实验，观测在验证集上的误差来找到。 卷积神经网络 卷积神经网络通过卷积运算来模拟人类视觉系统来提取空间上的信息，是一种非常适合于处理具有类似网格结构的数据的神经网络。一般将至少使用一层卷积运算的网络称为卷积神经网络，而使用卷积运算的层则称为卷积层（Convolution Layer）。以2维卷积层为例，卷积运算以一个2维矩阵$I$作为输入（Input），以另一个2维矩阵$S$作为输出（Output）。卷积运算通常以$\\ast$表示，定义如下： $$ S(i,j)=(I \\ast K)(i,j)=\\sum_{m=0}^{k_m} \\sum_{n=0}^{k_n} I(i+m,j+n)K(m,n) $$ 其中，$K$被称为卷积核（Convolution Kernel），是需要通过模型优化进行学习的矩阵参数。$k_m$和$k_n$定义了2维矩阵$K$的形状，是一种称为卷积核大小（Kernel Size）的超参数（Hyperparameter）。超参数指的是在机器学习中，在模型优化前需要人为指定的参数。 2维矩阵卷积计算过程如下图所示： 该图表示了当2维矩阵$I$的大小为3$\\times$3，$k_m$和$k_n$均为2时，卷积运算的步骤与结果。可以注意到，在卷积层中，参数的数量仅仅与卷积核大小，即$k_m$和$k_n$的值有关。采用较小的卷积核，会导致神经网络参数量下降，难以学习复杂的表示，而采用较大的卷积核，则会增加计算量，增加硬件负担。因此，采用卷积神经网络架构时，卷积核大小是一个非常重要的参数。 为了在时空间序列预测问题上使用卷积架构，需要考虑输入矩阵和输出矩阵大小的问题。注意到在经过2$\\times$2卷积核$K$的卷积计算后，输入2维矩阵的大小从3$\\times$3降为了输出2维矩阵的大小2$\\times$2，即，卷积计算会减少矩阵的大小，但是在时空间序列预测问题上，期望得到的预测$\\mathcal{X}$的大小应当与输入矩阵的大小相同。为了解决这个问题，这里引入填充（Padding）操作。填充操作通过在输入矩阵的周围填充数据，可以使输入矩阵的大小和输出矩阵的大小保持一致，一般选择填入的数据为0。以大小为3$\\times$3的输入矩阵为例，在输入矩阵四周分别填充一行0后，输入矩阵的大小变为5$\\times$5，经2$\\times$2的卷积核卷积计算后，输出矩阵的大小为3$\\times$3，保证了卷积前后输入输出矩阵的大小一致。 另外一个需要考虑的问题是输入输出维度的问题。时空间序列预测模型的期望输入和输出矩阵为3维矩阵，需要对2维卷积运算进行扩展： $$ S^{(p)}(i,j)=(I \\ast K)(i,j)=\\sum_{l=0}^{L} \\sum_{m=0}^{k_m} \\sum_{n=0}^{k_n} I(l,i+m,j+n)K^{(p)}(l,m,n) $$ 由于输入矩阵$I$变为3维矩阵，因此卷积核$K$也相应的拓展为3维矩阵，矩阵大小为$L \\times k_m \\times k_n$，即在变量维度上与输入矩阵的维度大小保持一致。注意到，对于某一个卷积核$K^{(p)}$，经卷积运算后，得到的输出矩阵$S^{(p)}$依旧为2维矩阵。为了便于多个卷积层之间的链式连接，一般使用多个卷积核对同一个输入矩阵$I$进行卷积运算，并将多个2维矩阵堆叠在一起作为输出，确保输出矩阵$S$同样为3维矩阵。 循环神经网络 对于时空间序列预测问题，所有观测到的系统状态$\\mathcal{X}$之间不是相互独立（Independently）的，这是因为未来的系统状态明显是受到过去系统状态的影响。虽然卷积神经网络解决了如何提取空间信息的问题，但依旧难以将时间上的信息纳入考量。循环神经网络29（Recurrent Neural Network，RNN）是一类用于处理序列数据的神经网络。通过引入状态变量，RNN得以保存过去的信息，同时使用过去的信息与当前的输入来确定当前的输出，有效达成了融合时间信息的目的。 一般的循环神经网络包含一个称为隐状态（Hidden State）的状态变量，以$h$表示。某时刻$t$的隐状态$h_{t}$由下式求得： $$ h_{t} = g(h_{t-1},x_{t};\\theta_{g}) $$ 其中，$g$和$\\theta_{g}$分别表示某种网络架构及其参数。为了得到当前时刻的输出，还需要经过下式计算： $$ y_{t} = f(h_{t};\\theta_{f}) $$ 其中，$f$和$\\theta_{f}$同样表示某种网络架构及其参数。因此，循环神经网络的计算过程可以由下图表示： 虽然在理论上，循环神经网络引入隐状态的设计可以捕获过去的信息用于与当前输入进行融合以获得当前输出，但事实上，正是因为这种设计，导致了RNN的梯度消失（Vanishing Gradient）问题30，简单","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:3:2","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"编程实现 本研究使用Python编程语言实现上述数据处理、模型构建以及模型优化的所有功能。Python语言有着简洁易读且扩展性强的特点，并且可以引入很多库（Library）来减小实现深度学习模型的难度。实现基于人工智能的大气污染扩散模拟的详细软件硬件配置如下表所示： 硬件/软件 型号/版本 CPU AMD Ryzen 7 3700X 8-Core Processer GPU NVIDIA GeForce GTX 1050 Ti 4GB 操作系统 Windows 11 21H2 编程语言 Python 3.9.7 矩阵运算库 NumPy 1.21.5 机器学习库 PyTorch 1.10.1 build:py3.9_cuda11.3_cudnn8_0 数据处理库 NetCDF4-Python 1.5.7 绘图库 Matplotlib 3.5.1、Plotly 5.7.0 本研究基于PyTorch库实现了深度学习模型。PyTorch是开源的机器学习库，内置了SGD、Adam等常用的模型优化算法及批标准化、权重衰减等正则化策略，便于直接调用，使得编程时可以聚焦于Conv-GRU的实现。同时，PyTorch支持使用GPU加速，大大缩短了模型优化所需要的时间。为了简化参数调整的过程，本研究在编程实现时留下了用于修改网络各个参数的接口，以便于修改网络参数。同时，本研究使用Matplotlib和Plotly库对模型实时训练效果和最终实验效果进行了可视化，可以直观感受不同参数对训练效果带来的影响。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:3:3","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"结果和讨论 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:4:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"实验结果 在构建基于深度学习的大气颗粒物污染扩散模型时，模型的超参数选择对模型最终的效果有很大的影响。为了详细比较不同模型、正则化策略和超参数对训练带来的影响，本研究以$PM_{10}$为研究对象，通过控制不同变量对模型进行优化并比较模型性能。本研究通过模型在测试集上的均方差来衡量当前参数下模型的性能。一般来说，模型在优化的过程中，模型在测试集上的均方差并不是一直在下降的，通常会保存模型优化过程中均方差最小时模型的参数。因此本研究以模型在优化过程中测试集上均方差的最小值作为模型性能比较的依据。 经多次超参数调整后，效果最佳的超参数组合如下表所示： 超参数 值 批量大小 4 时间步数 5 隐状态维度 64 卷积核大小 5 批标准化 True 权重衰减 0.0005 模型优化过程中，模型在训练集和测试集的均方差如下图： 实验结果1 如图所示，在第60轮（Epoch）优化时，模型测试集均方差达到最小值30.047，而经200轮优化后，模型训练集均方差达到6.082。可以看出，模型在训练过程中，测试集上的均方差不断减小，训练集上的均方差则先减小后增大，两者之间的差距越来越大，这个差距便被称为泛化差距。 将模型替换为Conv-LSTM模型后，模型优化过程中模型在训练集和测试集的均方差如下图： 实验结果2 在第50轮优化时，Conv-LSTM模型在测试集上的均方差达到最小值35.154，明显劣于Conv-GRU模型，性能较差同时，Conv-LSTM的优化时间和内存消耗也不及Conv-GRU模型。Conv-GRU模型的优化速度可以达到每秒3.428个样本，并且模型参数仅有6594KB，与之相比，Conv-LSTM模型的优化速度仅有每秒3.063个样本，并且模型参数达到了8778KB。并且可以看出，与Conv-GRU模型相比，Conv-LSTM模型的泛化差距始终较大，模型泛化能力较差。 以同样的超参数，$PM_{2.5}$预测模型在模型优化过程中，模型在训练集和测试集上的均方差变化如下图： 实验结果3 在第120轮优化时，模型测试集均方差达到最小值24.083，经200轮优化后，模型训练集均方差达到4.061。与$PM_{10}$相比，$PM_{2.5}$模型的均方差明显更小，这是由大气中$PM_{2.5}$浓度小于$PM_{10}$导致的。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:4:1","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"误差分析 以WRF-Chem的输出为基准，神经网络预测产生误差的原因主要有以下2个方面： 万能近似定理38表明，一个前馈神经网络如果具有线性输出层和至少一层具有任何一种“挤压（squeeze）”性质的激活函数的隐藏层，只要给与网络足够数量的隐藏单元，它就可以以任意精度来近似任何一个从一个有限维空间到另一个有限维空间的Borel可测函数。但是这个足够数量的隐藏单元往往可能大到不可实现。以同类视频预测问题举例，在Moving MNIST数据集上，目前效果最好的深度网络模型Crevnet39的均方差为 22.3，而其模型参数达到了195MB（本研究由于硬件限制，模型参数仅有6.5MB左右）。 尽管万能近似定理表明无论试图学习什么函数，一个足够大的前馈神经网络一定能够表示这个函数，但并不意味着训练算法一定能学习这个函数。主要有以下两点原因：（1）训练算法可能找不到用于期望函数的参数值。这可能由不当的超参数（例如学习率，weight decay等）设置不当，或计算机存储的数值出现下溢等原因引起。（2）训练算法可能由于过拟合而选择了错误的参数。这可能由数据量不足，数据分布不均匀等原因引起。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:4:2","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"结论 本研究提出了基于Conv-GRU的大气颗粒物污染扩散模拟模型，并通过拟合WRF-Chem的输出对模型进行优化。与其它有关研究相比，本研究主要有以下特点：（1）充分利用时空间大气污染物浓度及气象信息，预测未来大气颗粒物的空间浓度分布；（2）采用了效率更高的深度学习模型，进一步提高了模型的运行速度，降低了模型运行的内存需求，提高了模型的精度；（3）调整了多个超参数并比较对模型训练效果的影响，进一步提升了模型的性能。 本研究基本取得了预期的研究目标，但是仍然存在一些不足和需要进一步研究的内容： （1）数据问题。由于现实数据收集困难，本研究的数据来源于WRF-Chem预测的污染物浓度分布，尽管WRF-Chem是较为准确的数值模型，但与真实环境之间仍有较大的差距，并且不能发挥统计模型不依赖于当前大气物理化学理论进展的优势。同时，数据量也是限制模型性能的一大关键，充足的数据量可以更好的发挥深度学习模型的性能。因此，如何收集足量真实环境的数据并据此优化模型是提高模型实用性的重点问题。 （2）模型问题。由于存在硬件限制，本研究仅实现了Conv-GRU一种模型并对该模型进行了优化。事实上，在深度学习时空间预测问题领域还有很多效果优秀的模型值得借鉴，优秀的模型有着更高的精度，更快运行速度以及更小的泛化差距，其它模型在大气颗粒物扩散模拟问题上的效果是下一步值得探讨的问题。 （3）优化问题。尽管本研究采用了一些正则化策略来减小泛化差距，但在本研究中较大的泛化差距依旧是影响模型性能最严重的问题。如何进一步减小泛化差距是提高基于深度学习的大气颗粒物污染扩散模型性能的关键问题，有待进一步研究。 ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:5:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["AI"],"content":"参考资料 中共中央 国务院关于深入打好污染防治攻坚战的意见 中央有关文件 中国政府网 ↩︎ 2020年中国生态环境状况公报 ↩︎ 室内外大气颗粒物和典型有机污染物的环境行为及人体呼吸暴露风险 ↩︎ The contribution of outdoor air pollution sources to premature mortality on a global scale ↩︎ Application of bias adjustment techniques to improve air quality forecasts ↩︎ Urban air quality and regional haze weather forecast for Yangtze River Delta region ↩︎ 国内外空气质量模型研究进展 ↩︎ ↩︎ ↩︎ CALPUFF Modeling System ↩︎ WRF-CHEM ↩︎ The Community Multiscale Air Quality Modeling System ↩︎ Progress on the Development and Application of Air Quality Models ↩︎ ↩︎ Statistical Modeling Approaches for PM10 Predictionin Urban Areas; A Review of 21st-Century Studies ↩︎ Dive into Deep Learning ↩︎ ↩︎ Deep Learning ↩︎ ↩︎ Reducing the Dimensionality of Data with Neural Networks ↩︎ 基于深度学习的大数据空气污染预报 ↩︎ Long Short-term Memory ↩︎ Long short-term memory neural network for air pollutant concentration predictions: Method development and evaluation ↩︎ Learning Phrase Representations using RNN Encoder-Decoder for Statistical Machine Translation ↩︎ Backpropagation Applied to Handwritten Zip Code Recognition ↩︎ Photo-Realistic Video Prediction on Natural Videos of Largely Changing Frames ↩︎ Unsupervised Learning of Video Representations using LSTMs ↩︎ Convolutional LSTM Network: A Machine Learning Approach for Precipitation Nowcasting ↩︎ 基于深度学习的大气细颗粒物污染时空预报研究 ↩︎ Video Prediction ↩︎ Network Common Data Form (NetCDF) ↩︎ netcdf4-python ↩︎ NumPy ↩︎ Learning representations by back-propagating errors ↩︎ Learning long-term dependencies with gradient descent is difficult ↩︎ On the Properties of Neural Machine Translation: Encoder-Decoder Approaches ↩︎ Deep Learning for Precipitation Nowcasting: A Benchmark and A New Model ↩︎ Empirical Evaluation of Gated Recurrent Neural Networks on Sequence Modeling ↩︎ Deep Residual Learning for Image Recognition ↩︎ Adam: A Method for Stochastic Optimization ↩︎ Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift ↩︎ How Does Batch Normalization Help Optimization? ↩︎ Multilayer feedforward networks are universal approximators ↩︎ CrevNet: Conditionally Reversible Video Prediction ↩︎ ","date":"2022-05-25","objectID":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/:6:0","tags":["Python","RNN","LSTM","GRU"],"title":"毕业设计-基于人工智能的大气颗粒污染物扩散模拟技术的研究","uri":"/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E5%9F%BA%E4%BA%8E%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%9A%84%E5%A4%A7%E6%B0%94%E9%A2%97%E7%B2%92%E6%B1%A1%E6%9F%93%E7%89%A9%E6%89%A9%E6%95%A3%E6%A8%A1%E6%8B%9F%E6%8A%80%E6%9C%AF%E7%9A%84%E7%A0%94%E7%A9%B6/"},{"categories":["leetcode"],"content":"简单记录：BFS or DFS?","date":"2022-05-16","objectID":"/lc691/","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":" 问题链接：贴纸拼词 ","date":"2022-05-16","objectID":"/lc691/:0:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":"思考 本题被 LeetCode 官方归为了一道 hard 题，但实际上仅仅使用深度优先搜索或广度优先搜索就能解决。与之相比，官方的题解（动态规划 + 记忆化搜索 + 状态压缩）才是实打实的 hard，能力有限，日后再解。 对于搜索来说，每个节点保存的信息包含两个部分：一是当前的 target。在搜索的每一步上，选择一个贴纸，并将贴纸中符合的字母贴在 target 上，这样 target 需要的字母将会越来越少。该搜索树的叶节点有两种可能：一是贴纸匹配，刚好可以拼凑出 target；二是贴纸无法匹配，无法拼凑出 target。而我们要搜索的，就是深度最低的匹配叶节点的深度。所以节点要保存的第二个信息为当前节点的深度，以便返回目标值。 ","date":"2022-05-16","objectID":"/lc691/:1:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":"代码 这里首先给出 DFS 的实现： class Solution: def minStickers(self, stickers: List[str], target: str) -\u003e int: @lru_cache(None) def dfs(target: str) -\u003e int: if not target: return 0 res = float('inf') for sticker in stickers: replacedWord = addSticker(sticker, target) res = min(res, dfs(replacedWord) + 1) return res def addSticker(sticker: Counter, word: str) -\u003e str: for char in sticker: word = word.replace(char, '', sticker[char]) return word stickers = [Counter(s) for s in stickers] res = dfs(target) return res if res != float('inf') else -1 事实上很好理解，从所有贴纸中去除一张，利用贴纸中的字母替换 target 后，将新的 target 传入到下一个节点，最后通过比较选出最短路径。想法非常美好，但是运行将会报错： RecursionError: maximum recursion depth exceeded while calling a Python object Python 默认递归深度最高只能为 1000，这是因为过深的递归可能会导致堆栈溢出。尽管可以使用 sys.setrecursionlimit 修改 Python 递归的深度限制，但这明显是治标不治本的方法：递归深度如此之深，程序运行效率堪忧。 那么如何限制递归的次数呢？有一个很明显的优化方式存在。注意程序中，我们不断使用贴纸替换掉部分 target，那么肯定存在这样两条路径：第一条路经，我们先使用贴纸 A、后使用贴纸 B 替换了 target；第二条路径：我们先使用贴纸 B、后使用贴纸 A 替换了 target。换句话说，我们的搜索中存在着大量的无意义重复。 如何解决这个问题呢？有一个相当简单的方式。且看代码： class Solution: def minStickers(self, stickers: List[str], target: str) -\u003e int: @lru_cache(None) def dfs(target: str) -\u003e int: if not target: return 0 res = float('inf') for sticker in stickers: if target[0] not in sticker: # 注意此行 continue replacedWord = addSticker(sticker, target) res = min(res, dfs(replacedWord) + 1) return res def addSticker(sticker: Counter, word: str) -\u003e str: for char in sticker: word = word.replace(char, '', sticker[char]) return word stickers = [Counter(s) for s in stickers] res = dfs(target) return res if res != float('inf') else -1 通过添加这一行，我们对搜索树展开做了一个巨大的限制：只有包含 target 中第一个字母的贴纸才可以展开搜索树。这会带来一个显而易见的影响：子树的数量大大降低了。那么这样做会导致结果的错误吗？答案是不会的。因为我们知道，先使用贴纸 A 后使用贴纸 B 和先使用贴纸 B 而后使用贴纸 A 的效果是相同的，这个加入的限制，仅仅会限制搜索树的展开，而不会对原先树里存在的节点的深度造成任何影响。 这样，我们就可以快速求得最少的贴纸数量，或者说搜索树的深度。结果如下： 执行用时: 112 ms，超过了 88% 的 Python3 提交记录。 内存消耗: 15.4 MB，超过了 81% 的 Python3 提交记录。 ","date":"2022-05-16","objectID":"/lc691/:2:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":"优化 在写 DFS 代码之前，我们是不是讨论过如何构建搜索树？本题可以使用 DFS 来搜索，那么 BFS 可以完成这项任务吗？答案肯定是可以的。并且 BFS 有着一项 DFS 不具备的优势：BFS 搜索到的第一个可行节点，一定就是目标节点。这是因为 BFS 是按深度进行展开的，那么搜索到的第一个可行节点之前，不会有别的可行节点比其深度更浅。 ","date":"2022-05-16","objectID":"/lc691/:3:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":"BFS 代码 class Solution: def minStickers(self, stickers: List[str], target: str) -\u003e int: availables = [Counter(st) for st in stickers] queue = deque([(target, 0)]) explored = {target} while queue: cur, step = queue.popleft() if not cur: return step for avl in availables: if cur[0] in avl: nxt = cur for k, v in avl.items(): nxt = nxt.replace(k, '', v) if nxt not in explored: explored.add(nxt) queue.append((nxt, step + 1)) return -1 最终效果： 执行用时: 76 ms，超过了 98% 的 Python3 提交记录。 内存消耗: 15 MB，超过了 97% 的 Python3 提交记录。 ","date":"2022-05-16","objectID":"/lc691/:4:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["leetcode"],"content":"伪 · 结尾碎碎念 怎么就是想不起来用 BFS 呢？？？ 这是为什么呢？？？ ","date":"2022-05-16","objectID":"/lc691/:5:0","tags":["Python","BFS","DFS","递归"],"title":"LC691 - 贴纸拼词","uri":"/lc691/"},{"categories":["Python"],"content":"磨刀不误砍柴功。","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":" 成功 用好内置的容器及方法是快速巧妙解题的关键！ ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:0:0","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"容器 ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:1:0","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"defaultdict 默认字典 collections.defaultdict 是一个特殊的字典，在实例化之前可以接受一个 factory_function，来当作当查询的键不存在的时候所返回的默认值。factory_function 指的是 list、set、str 等等。 举例： \u003e\u003e\u003e import collections \u003e\u003e\u003e dic = dict() \u003e\u003e\u003e dedic = collections.defaultdict(str) \u003e\u003e\u003e dic[0], dedic[0] = \"Deep\", \"Dark\" \u003e\u003e\u003e dic[0] 'Deep' \u003e\u003e\u003e dic[1] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e KeyError: 1 \u003e\u003e\u003e dedic[0] 'Dark' \u003e\u003e\u003e dedic[1] '' \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:1:1","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"deque 双端队列 collections.deque 全称为 double-end queue，也就是双端队列。可以通过该容器模拟栈或者队列，从而获得比 list 更好的性能。 举例： \u003e\u003e\u003e import collections # 队列 \u003e\u003e\u003e queue = collections.deque() \u003e\u003e\u003e queue deque([]) \u003e\u003e\u003e queue.append(1) \u003e\u003e\u003e queue.append(2) \u003e\u003e\u003e queue.append(3) \u003e\u003e\u003e queue deque([1, 2, 3]) \u003e\u003e\u003e queue.popleft() 1 \u003e\u003e\u003e queue deque([2, 3]) # 堆栈 \u003e\u003e\u003e stack = collections.deque() \u003e\u003e\u003e stack deque([]) \u003e\u003e\u003e stack.append(1) \u003e\u003e\u003e stack.append(2) \u003e\u003e\u003e stack.append(3) \u003e\u003e\u003e stack deque([1, 2, 3]) \u003e\u003e\u003e stack.pop() 3 \u003e\u003e\u003e stack deque([1, 2]) \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:1:2","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"collections.Counter 计数器 Counter 是 dict 的一个子类，用于计数可哈希对象。 举例： \u003e\u003e\u003e import collections \u003e\u003e\u003e c = collections.Counter(\"ABSBSBSBSBSBSBSB\") \u003e\u003e\u003e c Counter({'B': 8, 'S': 7, 'A': 1}) \u003e\u003e\u003e c.update(\"ABABA\") \u003e\u003e\u003e c Counter({'B': 10, 'S': 7, 'A': 4}) \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:1:3","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"方法 ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:0","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"heapq 堆 heapq 方法可以将 list 中元素在线性时间内调整为小根堆。 举例： \u003e\u003e\u003e import heapq \u003e\u003e\u003e l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0] \u003e\u003e\u003e heap = heapq.heapify(l) \u003e\u003e\u003e l [0, 1, 3, 4, 2, 6, 7, 8, 9, 5] \u003e\u003e\u003e heapq.heappush(l, 10) \u003e\u003e\u003e l [0, 1, 3, 4, 2, 6, 7, 8, 9, 5, 10] \u003e\u003e\u003e heapq.heappop(l) 0 \u003e\u003e\u003e heapq.heappop(l) 1 \u003e\u003e\u003e heapq.heappop(l) 2 \u003e\u003e\u003e l [3, 4, 6, 8, 5, 9, 7, 10] \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:1","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"bisect 二分查找 bisect 方法支持对有序列表的二分查找。 举例： \u003e\u003e\u003e import bisect \u003e\u003e\u003e l = [3, 5, 5, 8, 10] \u003e\u003e\u003e bisect.bisect_left(l, 5) # 若元素存在，返回最左边符合条件的位置 1 \u003e\u003e\u003e bisect.bisect_right(l, 5) # 若元素存在，返回最右边符合条件的下一个位置 3 \u003e\u003e\u003e bisect.bisect_left(l, 4) 1 \u003e\u003e\u003e bisect.bisect_right(l, 4) # 若元素不存在，返回分割点。 1 ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:2","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"map 映射 map 方法将提供的函数对给定的序列做映射并返回迭代器。 举例： \u003e\u003e\u003e def A(): ... return ... \u003e\u003e\u003e A() \u003e\u003e\u003e A() == None True \u003e\u003e\u003e def f(x): ... return x ** 2 ... \u003e\u003e\u003e ite = map(f, [1,2,3,4,5,6]) \u003e\u003e\u003e while True: ... print(next(ite)) ... 1 4 9 16 25 36 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 2, in \u003cmodule\u003e StopIteration \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:3","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"itertools.pairwise 叠对 pairwise 方法返回从迭代器中获取的连续叠对。 这是 Python 3.10 新增的方法。 举例： \u003e\u003e\u003e import itertools \u003e\u003e\u003e list(itertools.pairwise(\"ABCDEF\")) [('A', 'B'), ('B', 'C'), ('C', 'D'), ('D', 'E'), ('E', 'F')] \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:4","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"sort 排序 sort 方法是列表所提供的方法，用于排序，其排序是稳定的，并且可以通过传入参数来自定义排序。可以参见 LC937 从新排列日志文件。 举例： \u003e\u003e\u003e l = [1, 2, 3, -4, 5, -6] \u003e\u003e\u003e l.sort() \u003e\u003e\u003e l [-6, -4, 1, 2, 3, 5] \u003e\u003e\u003e l.sort(reverse=True) \u003e\u003e\u003e l [5, 3, 2, 1, -4, -6] \u003e\u003e\u003e l.sort(key=lambda x: abs(x)) \u003e\u003e\u003e l [1, 2, 3, -4, 5, -6] \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:5","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["Python"],"content":"itertools.combinations 组合 combinations 方法返回一个迭代器，迭代内容为可迭代对象的全部非重复组合。这里的非重复指的是位置非重复。 举例： \u003e\u003e\u003e import itertools \u003e\u003e\u003e list(itertools.combinations('ABCD', 2)) [('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'C'), ('B', 'D'), ('C', 'D')] \u003e\u003e\u003e list(itertools.combinations('ABCD', 3)) [('A', 'B', 'C'), ('A', 'B', 'D'), ('A', 'C', 'D'), ('B', 'C', 'D')] \u003e\u003e\u003e ","date":"2022-05-08","objectID":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/:2:6","tags":["Python"],"title":"Python常用内置容器及方法","uri":"/python%E5%B8%B8%E7%94%A8%E5%86%85%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%8F%8A%E6%96%B9%E6%B3%95/"},{"categories":["leetcode"],"content":"简单记录：做题应当由浅入深。","date":"2022-05-08","objectID":"/lc433/","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":" 问题链接：最小基因变化 ","date":"2022-05-08","objectID":"/lc433/:0:0","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":"思考 假设没有 bank 的存在，所有的变化都是可行的时候，本题最小基因变化，其实就是在求 start 基因到 end 基因之间的距离。这里的距离定义为，两个基因之间字符不同的数量。因为当所有的基因变化都是有效的时候，我们只需要让每次基因变化，都将 start 中一个与 end 中不同的字符变为相同即可。 与自由变化（没有 bank）不同的是，在自由变化的搜索过程，我们知道一定存在最短的路径使得 start 经过最小次数的变换之后变成 end。但是当 bank 存在的时候，这样一条最短路径可能并不存在，例如： start = \"AACCGGTT\" end = \"AAACGGTA\" bank = [\"AACCGATT\",\"AACCGATA\",\"AAACGATA\",\"AAACGGTA\"] 可以看到，在这种情况中，start 和 end 之间的距离为 2，但是 bank 中不能提供这种最短路径，而是必须借助一个跳板，最终路径为：\"AACCGGTT\" -\u003e \"AACCGATT\" -\u003e \"AACCGATA\" -\u003e \"AAACGATA\" -\u003e \"AAACGGTA\"。也就是说，虽然在变异过程中出现了 start 与 end 之间 距离增加的情况，但这是唯一的可行解。 为了解决这种问题，最简单无脑的方式就是对所有的可行解都进行搜索。 对一个树进行搜索的方式有深度优先搜索和广度优先搜索。因为本题需要返回的是变异的最短路径，假如我们选择深度优先搜索，这会导致我们搜到一个可行解的时候，必须考虑这个可行解是不是最优解，从而不得不搜索所有的情况。而当我们选择广度优先搜索时，我们搜到的第一个可行解一定是最优解，这是因为 BFS 是在搜索的过程中，下一个节点距起点的距离不可能小于当前节点，所以本题采用 BFS。 ","date":"2022-05-08","objectID":"/lc433/:1:0","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":"代码 新建一个队列，将 start 加入到队列当中。每次从队列中取出一个节点，从 bank 中搜索未访问过的并且当前节点可以到达的下一个节点 ，并将其加入对列。当下一个节点为 end 时直接返回最终结果；当队列为空时，返回 end 不可达。 class Solution: def distance(self, start, end): dis = 0 for i, j in zip(start, end): if i != j: dis += 1 return dis def minMutation(self, start: str, end: str, bank: List[str]) -\u003e int: queue = deque() queue.append((start, 0)) bank = set(bank) visit = [] res = [] while queue: curgen, curdis = queue.popleft() if curgen == end: return curdis visit = [] for gen in bank: if self.distance(gen, curgen) == 1: queue.append((gen, curdis + 1)) visit.append(gen) for gen in visit: bank.remove(gen) 执行用时: 40 ms，超过了 41% 的 Python3 提交记录。 内存消耗: 15 MB，超过了 37% 的 Python3 提交记录。 ","date":"2022-05-08","objectID":"/lc433/:2:0","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":"小改进 class Solution: def distance(self, start, end): return sum(i != j for i, j in zip(start, end)) def minMutation(self, start: str, end: str, bank: List[str]) -\u003e int: graph = defaultdict(list) for geni, genj in combinations([start] + bank, 2): if self.distance(geni, genj) == 1: graph[geni].append(genj) graph[genj].append(geni) queue = deque() queue.append((start, 0)) visit = set() while queue: curgen, curdis = queue.popleft() for nexgen in graph[curgen]: if nexgen == end: return curdis + 1 if nexgen in visit: continue else: visit.add(nexgen) queue.append((nexgen, curdis + 1)) return -1 与初始代码主要的区别是，这里采用了先计算全部可行的走法组合，将每个节点可行的走法存储在字典中，再进行 BFS 的做法。由于字典的增时间复杂度小于删和查，所以时间消耗有了进一步的减少： 执行用时: 32 ms，超过了 87% 的 Python3 提交记录。 内存消耗: 15.1 MB，超过了 9% 的 Python3 提交记录。 ","date":"2022-05-08","objectID":"/lc433/:3:0","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":"伪 · 结尾碎碎念 为什么没啥可讲的，还要记录这道题呢？这是因为这道题： 今天没能完全独立做出来。我一开始以为这题用纯纯的 BFS 会超时，就想了很多花里胡哨的办法，最后写了俩小时给自己写不会了，实在头痛点开题解一看，好嘛，纯纯 BFS。只能说，以后做题要先把最简单的方法实现了再去想如何优化，眼高手低的后果是等于个零😀。 这题还有很多解法可以扩展。这里先占个位置，等整明白了把双向 BFS、A* 等算法也补上。 另外：现在是2022/5/8 2:36，刚才 LeetCode CN 好像崩了，提交没反应一直转圈。 ","date":"2022-05-08","objectID":"/lc433/:4:0","tags":["Python","BFS"],"title":"LC433 - 最小基因变化","uri":"/lc433/"},{"categories":["leetcode"],"content":"找出隐藏在模拟之下的数学规律是巧解本题的关键。","date":"2022-05-05","objectID":"/lc1823/","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":" 问题链接：找出游戏的获胜者 ","date":"2022-05-05","objectID":"/lc1823/:0:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"思考 本题就描述而言并不困难，可以很轻松的想出基于模拟的做法。数字按顺序绕成一圈，明显为单循环链表，接下来仅仅需要按照题目描叙，指针每次向下移动一位，移动到 $k$ 的整数倍后便将指针所指节点删去，直至最后只剩一个节点，该节点即为游戏的获胜者。 对于单纯的模拟来讲，只需要实现计数和单循环链表节点的删除即可轻松拿下本题。但是我们可以注意到，维护一个单循环链表，并不断地从链表上删除元素，所消耗的时间复杂度是很高的，并且这个动作并不是无可取代的。 具体而言怎样实现呢？此处提供一个不需要维护单循环链表的思路。 对于没有插入动作的单循环链表，我们可以用数组对其进行模拟。我们可以完全可以申请一片连续的内存空间：对于单循环链表指针的移动而言，可以使用取余来实现。我们可以将指针设为一个整形，每次移动意味着指针值 $+1$，当指针值，或者说数组下标超出数组长度后，对指针值除以数组长度做取余运算，指针值便又回到了最初的 $0$，意味着开始指针回到链表头的位置，开始了新一轮的循环。这样便会带来一个问题，那就是我们需要额外增加一个变量来记录数过了几个小伙伴，这是因为指针值（数组下标）会发生变化，单纯将指针值的 $k$ 倍所在的节点进行删除并不能删除正确的节点。 对于单循环链表节点的删除而言，由于小伙伴们的取值为从 $1$ 开始的整数，我们可以将已经被淘汰的小伙伴的值设为 $-1$，来代指小伙伴已经被从链表上删除，当指针经过被淘汰的小伙伴的时候，指针值 $+1$，但数过的小伙伴的数量保持不变（也就是在指针的移动步骤中最后增加的变量）。这样，我们就增加两个变量，使用数组取代了时间复杂度更高的单循环链表以及其维护操作。 ","date":"2022-05-05","objectID":"/lc1823/:1:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"代码 class Solution: def findTheWinner(self, n: int, k: int) -\u003e int: gamer = [i for i in range(1, n + 1)] # 使用数组来代表所有参加游戏的小伙伴 count, ptr, alive = 0, -1, n # count 为在游戏中已经数过了多少个小伙伴，ptr 为指针（数组下标） # alive 为现在剩余的小伙伴数量，每次淘汰一个小伙伴，alive - 1 while True: ptr += 1 # 指针移动到下一个位置 ptr = ptr % n # 当指针超出数组下标后，回到原点 if gamer[ptr] == -1: # 如果指针当前位置的小伙伴已经被淘汰 continue # 不再做任何操作 else: # 如果未被淘汰 if alive \u003e 1: # 并且场上存活的小伙伴数量 \u003e 1 count += 1 # 数过一个小伙伴 if count % k == 0: # 如果已经数到了第 k 个小伙伴 gamer[ptr] = -1 # 将小伙伴淘汰 alive -= 1 # 场上存活的小伙伴数量 - 1 else: # 如果场上只剩余 1 名小伙伴 return gamer[ptr] # 返回该名小伙伴 模拟代码并不难，最终结果也并不好🤣： 执行用时: 1256 ms，超过了 0% 的 Python3 提交记录。 内存消耗: 14.9 MB，超过了 64% 的 Python3 提交记录。 有点搞笑了只能说，怕不是紧贴着 TLE 通过的。 ","date":"2022-05-05","objectID":"/lc1823/:2:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"优化 当暴力效果不好的时候，我们要做的便是用数学的眼光来发掘其内在规律，减少无用功。当然，互联网时代，如此便利的条件我们更应该站在巨人的肩膀上（面向搜索引擎解题）。 闲话休叙。了解了一下之后发现，从 $0$ 开始，首尾相接，每次数 $k$ 并将其淘汰，称之为约瑟夫环。也就是说，本题就是原汁原味的约瑟夫环问题，仅仅是将开头给换成了 $1$。事实上，本题可以使用归纳的方式寻找出规律。 关于约瑟夫环，很有趣的一点便是，在第一轮循环中，只要 $k$（每次淘汰要数几个数）相同，那么无论 $n$（约瑟夫环中节点总数）为多少，第一次淘汰的位置总是一样的。当然我们这里假设 $n \u003e k$。以图为例： 假设 $k = 3$ 那么我们将要淘汰的数字为环中第 $3$ 个数，也就是 $2$。可以看到，图中两环虽然 $n$ 不相同，但是所淘汰的数是相同的。 注意 我们大可以一直不停的淘汰下去，但是这样解决不了任何问题。因为一直淘汰下去又会使问题回归到模拟，现在我们应当试图寻找一些规律。 这里我们先将 $n = 9$ 的环上的数进行淘汰： 现在，两个约瑟夫环的 $n$ 是相同的，但是很难找到规律，因为上环已经断开，而下环依旧完好，两者结构相差太多。如果我们简单的将断处续接，也就是连接 $1$ 和 $3$： 事情似乎并没有朝着我们想要发掘的内在规律靠拢，第一次循环中要被淘汰的数错列排布，依旧让人摸不到头脑。 退回到上一步，重新考虑这个约瑟夫环的问题。是的，现在我们考虑的是一个环，也就是说这些数是首尾相接的。既然 $1$ 和 $3$ 相接看不出端倪，那么 $0$ 和 $8$ 相接又如何呢？ 我们注意到，需要淘汰的数，和存活的数，竟然排列在了一起！并且在数组的前 $6$ 位，我们可以注意到，上排数和下排数相差为定值 $3$ ，这很容易理解，因为我们将第一轮存活的数接在了数组的尾部，共 $2$ 个数，而第 $3$ 个数，也就是 $k$ 的倍数被淘汰。将数组上下对齐后，上排数和下排数差值为定值，也就是 $k$。 似乎忘记了续接的两个数？无需担心，因为这个问题我们早就在模拟解法中使用余数解决了。也就是说： 对于前 $6$ 个数，上下数组之间的对应关系为差值 $k$，例如 $4 = 1 + k = 1 + 3$。 对于后 $2$ 个数，上下数组之间的对应关系为差值 $k$ 及除以 $n$ 的余数，例如 $0 = (6 + 3) \\% 9$。 也就是可以表示为： 至此，我们找到了一种上下对应的关系。换句话说：如果我们已知 $n=8,k=3$ 时何数的去留，我们便能通过数学关系 $(x+k) \\% n$ 得知 $n=9,k=3$ 时何数的去留。这是因为由上图可知，去留关系应该是一一对应的。 注意 我们考虑的问题为约瑟夫环，这个环是首尾相接的，对上图而言，两环的差距，仅仅在标上的数字不相同。而由约瑟夫环的特性我们可以知道，对于一个约瑟夫环，只要起点相同，$n$ 和 $k$ 相同，那么对应位置的数字最终存活与否肯定是相同的。现在我们通过一个数学转换找到了数字之间的对应关系。 当然了，你可能会注意到，我 $2$ 怎么没了？上环的数字 $2$ 已经为了寻找规律而被淘汰，但这不重要。因为我们知道，最后的胜者肯定不会在最开始就被淘汰！因为我们所求的是最后的胜者！现在，我们假设 $f(n,k)$ 为该条件下最后的胜者，那么我们可以知道，其肯定不会被淘汰，也就是该数一定是符合下述关系的： $$ f(n,k) = (f(n-1,k) + k) \\% n $$ 而我们又知道，如果仅有一个数，那么无论 $k$ 为多少，最后赢家一定是它，也就是约瑟夫环最开始的那个数 $0$。数学表达式为： $$ f(1,k)=0 $$ 现在，无论 $k$ 的值是多少，我们都能在 $\\mathcal{O}(n)$ 的时间复杂度下，利用递推公式求出最后的赢家！ ","date":"2022-05-05","objectID":"/lc1823/:3:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"约瑟夫环代码 class Solution: def findTheWinner(self, n: int, k: int) -\u003e int: return 1 if n == 1 else (self.findTheWinner(n - 1, k) + k - 1) % n + 1 # 递推公式 将多行代码优化至一行！数学，很神奇吧！ 提示 你可能已经注意到本题与约瑟夫环的不同，那就是约瑟夫环起始数为 $0$ 而本题起始数为 $1$。这也不难解决，只需要在输出结果后使结果 $+1$ 并在进行约瑟夫环递归计算前将其减去即可。 最终效果： 执行用时: 40 ms，超过了 71% 的 Python3 提交记录。 内存消耗: 15.3 MB，超过了 8% 的 Python3 提交记录。 ","date":"2022-05-05","objectID":"/lc1823/:4:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"最后优化 上述代码使用递归实现，递归到最后有一个堆栈返回的过程，这还可以进行优化。将递归替换为迭代，也就是将倒着求结果换成正着推，并不难实现，代码如下： class Solution: def findTheWinner(self, n: int, k: int) -\u003e int: res = 0 # 起始条件 for i in range(n): res = (res + k) % (i + 1) # 约瑟夫环递推公式 return res + 1 # 最终结果 + 1 因为本题数字从 1 开始 最后节约了 4ms 的执行时间和大量的内存： 执行用时: 36 ms，超过了 89% 的 Python3 提交记录。 内存消耗: 14.8 MB，超过了 93% 的 Python3 提交记录。 ","date":"2022-05-05","objectID":"/lc1823/:5:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":["leetcode"],"content":"结尾碎碎念 距离上次写题解过去了好多天，并不是因为我懒，这里还是要反思一下刷题的技巧的。 最开始我是顺着题目顺序刷题，事实上很多简单题做起来确实没有什么好讲的地方，导致没有什么收获。而困难题呢，又因为难度太高，就算勉强做出来，也不至于能到达清晰的梳理好题目的程度，收获甚微。反而是中等题，常常能带来很多有益的思考。我并不是说困难题和简单题就没有不能带来这种思考，只是出现的频率较少罢了。最近在按照每日一题来做，收获还是不错了。 前几天试着做了一下全站通过率最低的 LCP60 力扣泡泡龙，做了一个半小时，总算是写了出来一个通过的结果。但是说实话诈胡成分比较高，怕是测试再复杂一些就要挂在时间上。光是做就已经绞尽脑汁，优化更是有心无力了。然后第二天又连做两道 hard，头昏脑胀，直接摸了一晚上。最后也没学到什么，只能说头铁 hard 不可取。 现在是 4:32 ，明天还得，哦，今天中午 12 点还得开会，得赶紧睡了。写题解还是很耗时间的，3 千字大概写了 130 分钟，估计回家备考就很难写这种长篇题解了。 这篇文章题解绘图用的是 Draw.io 这款软件，还挺好用的。 不知道为啥公式内百分号不能正常显示，还得再研究一下。 Update：百分号前要加双反斜杠进行转义，目前不清楚原因。 最后就是，《相合之物》这动画片真好看！ ","date":"2022-05-05","objectID":"/lc1823/:6:0","tags":["Python","模拟","递归","迭代","约瑟夫环"],"title":"LC1823 - 找出游戏的获胜者","uri":"/lc1823/"},{"categories":null,"content":"Blathers' friends","date":"2022-05-01","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"基本资讯 - nickname: Blathers avatar: https://gravatar.loli.net/avatar/1cc24367e7133aceb81bfd9ef41481cd?s=240\u0026d=mp url: https://blathers233.netlify.app description: Blathers' Tent ","date":"2022-05-01","objectID":"/friends/:1:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"友情提示 提示 If you want to exchange link, please leave a comment in the above format. (personal non-commercial blogs / websites only) Warn: Website failure, stop maintenance and improper content may be cancelled! Those websites that do not respect other people’s labor achievements, reprint without source, or malicious acts, please do not come to exchange. ","date":"2022-05-01","objectID":"/friends/:2:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":["教程"],"content":"本文旨在提供使用 Hugo + GitHub Pages or Netlify + Waline + PicGo 搭建个人博客的轻松无脑一站式体验教程。","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":" 轻松拿下 Hugo，因为我站在大佬的肩膀上。 提示 如有问题欢迎与我联系😀。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:0:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"0. 安装 Hugo Hugo 可以选择二进制安装或者自行下载源码编译安装。此处选择轻松简单快捷的二进制安装。进入 Hugo Releases，根据你的操作系统选择相应的版本。在此处我推荐安装 Hugo_extended 版本。该版本可以允许你更加轻松的修改主题。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:1:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"1. 生成站点 以 Windows 系统为例，下载二进制程序后，在程序所在文件夹打开 PowerShell，运行： .\\hugo new site .\\your_stie_name 即可在 .\\your_site_name 路径下生成你的站点文件夹。现在： cd .\\your_site_name ..\\hugo new about.md 就可以看到 about.md 自动生成到了 \\your_stie_name\\content 文件夹下。请注意，当前你的 PowerShell 的路径应当在 \\your_stie_name，这意味着 Hugo 将为该站点生成 about.md。事实上，你可以通过 Hugo 生成并管理多个站点。 提示 你也可以不通过 hugo new 而是手动新建 .md 文件在 \\content 文件夹下。你所有的页面都将由该文件夹下的 .md 文件生成。 现在打开 about.md，你将看到： --- title: \"About\" date: 2022-04-19T21:43:04+08:00 --- 正文内容 夹在两排 --- 之间的内容是对将要生成的页面的描述，包含了标题，日期等内容。现在创建第一篇文章，放到 posts 目录，方便之后生成聚合页面： ..\\hugo new posts\\first.md 打开并编辑 first.md： --- date: \"2022-04-19T23:33:33+08:00\" title: \"first\" --- # Hello Hugo 1. aaa 2. bbb 3. ccc 就可以对你将要发布的页面进行编辑。此时你可能正在寻找一款好用的 Markdown 编辑器， Typora 是很棒的选择。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:2:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"2. 挑选主题 在正式发布你的页面之前，你还需要为页面挑选一款耐看的主题。进入 Hugo themes 网页挑选主题并下载后，将其解压到 \\your_stie_name\\themes 文件夹下，例如我下载了 Diary 主题，那么我的文件夹布局为：\\your_stie_name\\themes\\diary。请注意，你可以将主题的文件夹修改成一个好记的名字，以后将多次键入这个文件夹的名字。 注意 不同的主题在一些细节上可能有所不同，当然这是日后的课题。对于不同的主题，你可以查询该主题的文档来获得更多的支持。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:3:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"3. 测试你的页面 在挑选并下载主题之后，你可以在本地运行你的博客并查看效果。在 \\your_site_name 打开 PowerShell，运行： ..\\hugo --theme=your_theme_name server 你就可以在 http://localhost:1313/ 预览网页的效果。值得一提的是，如果你此时对 about.md 或者 config.toml （稍后会讲到）等进行修改并保存，这些改动将会实时的反映在你的网页上。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:4:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"4. 发布你的页面 当你对页面改动满意后，你可以将你的页面发布到 GitHub 上以便使用 GitHub Pages 来托管你的网页。首先在 GitHub 上为你的 Blog 新建一个仓库，然后在 your_site_name 文件夹下运行： ..\\hugo --theme=your_theme_name 运行结束后，你的页面将会被保存到 \\your_site_name\\public 文件下，接下来你可以将该文件夹上传到仓库，运行： cd .\\public\\ git init git remote add origin https://github.com/your_user_name/your_repo_name.git git add . git commit -m 'first commit' git push -u origin master ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:5:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"5. GitHub Pages or Netlify 进入你的仓库，选择 settings - pages，Source 选择 master，folder 选择 \\(root)，然后点击 save。一段时间后，你的 GitHub Pages 就可以成功访问了。这里建议将仓库命名为 your_user_name.github.io，这样的话，你的主页网址将为：https:\\\\your_user_name.github.io 。对于一般仓库名，你的主页网址将为：https:\\\\your_user_name.github.io\\your_repo_name。 除了 GitHub Pages 外，你也可以选择其他的静态页面托管服务。这里简短介绍 Netlify。只需要通过 GitHub 登录 Netlify，你就可以直接将仓库中的网页部署在 Netlify 中，并且支持自定义域名和自动部署等便利的功能。 访问你的页面，你可能会发现一些问题，例如点击页面链接后跳转失败等。这些问题需要通过一些设置来解决。👇 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:6:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"6. config.toml 该文件位于 \\your_site_name 文件夹下，页面的大多数设置都可以在此处调整。首先应当调整 baseURL 项为你的主页网址。这样就可以使链接跳转正常。 除此之外，页面的其他设置也可以在此处调整。例如页面的边栏 sidebar，你可以在 config.toml 文件中添加: [[menu.main]] url = \"/posts\" name = \"Archive\" weight = 1 [[menu.main]] url = \"/tags\" name = \"Tags\" weight = 2 [[menu.main]] url = \"/categories\" name = \"Categories\" weight = 3 [[menu.main]] url = \"/about\" name = \"About\" weight = 4 就可以将页面调整的边栏调整为4个选项，分别是 Archive、Tags、Categories 和 About。对于 \\about ，在 \\content 文件夹内，该地址为一个 .md 文件，因此该边栏选项点击后将呈现 About 页面，也就是根据你在 about.md 中所键入内容生成的网页。对于 \\posts ，在 \\content 文件夹下，该地址为一个文件夹，因此该边栏选项点击后将呈现一个页面聚合。\\tags 和 \\categories 则是自动对标签和分类进行聚集生成的页面，有关标签和分类的内容将会在稍后讨论。 提示 有关 \\ 和 / 的差别，这是 Windows 和 Linux 的一个稍稍的不同。 另外一个例子是网页图标，你也可以在 config.toml 中进行控制，你可以输入： [params] favicon = \"your_image_path\" 来控制网页的图标位置。你需要将你的图片放入到 \\your_site_name\\static\\images 文件夹下。例如我将图片 QUIN.png 放置到该文件夹中，对于 GitHub Pages 的一般仓库名，我的 \"your_image_path\" 应当为 \"\\your_repo_name\\images\\QUIN.png\"，而对于 Netlify 和 GitHub Pages 的独有仓库名，我的\"your_image_path\" 应当为 \"\\images\\QUIN.png\"。 注意 尽管这种方式可以正确的加载网页图标和页面头图（稍后会讲到），但是这种方式并不能很好的支持页面内图片的内容，我不清楚这是什么原因。但是这种方式来放置页面内图片，不仅会导致本地编辑 .md 文件时不能正常预览图片，服务端有限的网速也会导致网页浏览体验下降，因此可以使用网络图床来解决这个问题。 提示 当然网页图标和页面头图也可以使用图床。 当然，网页当中还有很多元素可以自定义，根据你使用的主题不同，又有一些额外的内容可以控制。对于额外的内容，你需要查询你选择的主题的文档，对于通用内容，你可以阅读 Hugo 文档来学习如何调整。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:7:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"7. 写作 完成上述设置后，推送你所完成的更改，可以看到网页已经可以正常使用了。接下来我们将要讨论的是写作中一些剩余的问题。在 .md 文件的开头，夹在两行 --- 之间的内容称为元数据（meta data）。这些元数据根据你所选主题的不同，可能会有些出入，请参考你所选择的主题其中的项目。这里以 Diary 主题为例，对一些元数据进行介绍： title: \"浅入浅出 Hugo 教程\" date: 2022-04-24T16:33:00+08:00 lastmod: \"2022-04-24\" description: \"轻松拿下 Hugo，因为我站在大佬的肩膀上。\" featured_image: \"\" tags: [Hugo, Blog] categories: 教程 comment: True enableLaTeX: False title：文章的标题 data：文章创建的时间 lastmod：文章最后修改的时间 featured_image：文章头图 tags：标签 categories：分类 comment：时候启用评论 enableLaTex：是否启用 LATEX 不同的主题可能有所出入，这里需要以你所用主题的文档为准。以主题 Diary 为例，当你为一篇文章添加 tags 和 categories 后，将会自动聚合内容生成 \\Tags 和 \\Categories 页面，尽管这两个文件夹并不在你 \\content 文件夹下。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:8:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"8. 评论区 危险 今天（2022.9.26）发现Waline部署依赖的Vercel已经在神秘力量的影响下不能登陆了，也就是评论区已经不能加载评论，可能需要转移。 今天（2022.9.26）晚上更换了Waline的服务端，部署到了Date上，访问速度非常舒适。具体操作参考Waline官方文档。唯一需要注意的是，提示Project不存在是需要到Date的Dashborad里设置一下项目的意思。 评论区很多不同的选择，在这里介绍 Waline 评论系统。对于主题 Diary 来说，已经内置了 Waline 评论系统，只需要在 config.toml 中添加： [params] walineServer = \"your_waline_server\" 即可添加评论区。对于其它主题，你可能需要查询其文档来确定是否原生支持 Waline，若不支持且你被允许修改主题的内容，你可以参考 Waline 官方教程来引入 Waline 评论系统。 一旦你可以正确的引入客户端，你就可以设置 WalineServer。设置 WalineServer 的方式也在 Waline 官网提供了详细的教程。这里提醒一点，当完成 WalineServer 的设置后，一定不要忘记注册评论管理页面，首个在评论管理页面注册的用户将成为评论区管理员。 对于 Waline 的其它功能，例如自定义表情，自定义样式等，你可能需要在主题的 HTML 文件中进行修改。以主题 Diary 为例，你需要打开位于 your_site_name\\themes\\diary\\layouts\\partials 文件夹下的 comment.html 文件，对其中的内容进行修改。 以添加自定义表情为例，你需要对 comment.html 下 new Waline 中的内容进行修改。如要添加哔哩哔哩的表情，你需要将 new Waline 中的内容修改为： \u003cscript\u003e new Waline({ el: '#waline', path: location.pathname, serverURL: {{.Site.Params.walineServer}}, emoji: [ 'https://cdn.jsdelivr.net/gh/walinejs/emojis@1.0.0/bilibili', ], }); \u003c/script\u003e 而以添加自定义样式为例，你则需要在 comment.html 中添加： \u003cstyle\u003e :root { /* 主题色 */ --waline-theme-color: #27ae60; --waline-active-color: #2ecc71; } \u003c/style\u003e 即可对主题色进行修改。更多内容，请参考 Waline 官方文档。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:9:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"⑨. 图床 优秀的图床可以大大提升网站浏览的体验，在这里推荐 PicGo 图片上传及管理工具。你可以在 PicGo releases 页面下载 PicGo。这里以 SM.MS 图床加 PicGo 简单介绍以下使用 PicGo 进行图片上传及管理的流程。 首先打开 SM.MS 官网，进行注册并登录后，点击 User - Dashboard，跳转页面后选择 API token，然后点击 Generate Secret Token 就可生成你的 token。 接下来打开 PicGo，选择 图床设置 - SM.MS图床，将上一步生成的 token 填入并点击确定，就完成了全部的设置。PicGo 同样支持很多其它图床，也包括自定义图床。其它内容请参考 PicGo 文档。 🙌 至此，本教程的全部内容已经施工完成。 ","date":"2022-04-24","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/:10:0","tags":["Hugo","Blog"],"title":"浅入浅出 Hugo 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAhugo%E6%95%99%E7%A8%8B/"},{"categories":["leetcode"],"content":"双指针真是太棒啦 -\u003e 二分查找也是。","date":"2022-04-24","objectID":"/lc15/","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":" 问题链接：三数之和 ","date":"2022-04-24","objectID":"/lc15/:0:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"思考 从一个列表中选出所有和为零的三个数的组合，并且不重复，最简单的方式即为三重 for 循环，然后排除重复的组合。时间复杂度为 $\\mathcal{O}(n^3)$。 ","date":"2022-04-24","objectID":"/lc15/:1:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"代码 class Solution: def threeSum(self, nums: List[int]) -\u003e List[List[int]]: nums.sort() length = len(nums) if length \u003c 3: return [] res = [] for i in range(0, length - 2): for j in range(i + 1, length - 1): for k in range(j + 1, length): if nums[i] + nums[j] + nums[k] == 0: el = [nums[i], nums[j], nums[k]] if el not in res: res.append(el) return res 三重 for 循环很容易实现，但是问题是如何排除重复项。重复项的三个数可能以不同的顺序排列，这增加了查重的难度。这里的方法是对首先对数组进行排序，这样保证所有可能中的数大小有序，减少排除重复项的难度。 然后简简单单的 TLE。 最容易想到的下一步改进方式就是，如果我们固定住三个数中的一个数，那么问题就转变为了 LC1 两数之和。对于两数字和来说，最佳的解法为 hashmap，时间复杂度为 $\\mathcal{O}(n)$，考虑外循环，时间复杂度来到了 $\\mathcal{O}(n^2)$。 class Solution: def twoSum(self, nums, target): res = [] map = {} for i in range(len(nums)): need = target - nums[i] if need in map: res.append([nums[map[need]], nums[i]]) else: map[nums[i]] = i return res def threeSum(self, nums): nums.sort() length = len(nums) if length \u003c 3: return [] res = [] for i in range(0, length - 2): others = self.twoSum(nums[i + 1:], target=-nums[i]) if others != []: for other in others: ele = [nums[i]] + other if ele not in res: res.append(ele) return res 这里与 LC1 的一个很大的不同是，twoSum 函数有多个可能的返回结果。这要求我们一定要遍历完所有的可能，导致虽然时间复杂度为 $\\mathcal{O}(n^2)$，运行速度依旧很慢，勉强为通过的结果。 执行用时: 4824 ms，超过了 5% 的 Python 提交记录。 内存消耗: 17.8 MB，超过了 67% 的 Python 提交记录。 ","date":"2022-04-24","objectID":"/lc15/:2:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针解法 在上述代码中，另一个时间消耗大户为排查重复项。有 hashmap 不便分析，回到最初的三重循环的想法：可以注意到，只要三重循环中的每一重循环都跳过重复项，就可以不需要最后额外的排查重复项。如果最初进行一次数组的排序，那么我们只需要检查当前值和上一步的值是否相同，就可以跳过重复项。这是因为排序后所有值相同的数全部相邻。 然而这就为 hashmap 解法引入了新的问题。注意到 hashmap 仅有一根指针，我们不能轻易排除重复项，这是因为 $target$ 很有可能等于相同的两项之和。例如 $target = 0$，$nums = [0, 0]$，此时如果我们跳过相同的数，那么将不会得到正确的返回结果 $[0, 0]$。为了正确的返回结果，还必须引入一个为每个元素进行计数的计数器。 那么有没有什么方式可以在引入双指针的同时将 twoSum 的时间复杂度降为 $\\mathcal{O}(n)$ 呢？这里，我们注意到数组已经有序。参考 LC11 的思路，对于任意的双指针 $j$ 和 $k$，假设 $j \u003c k$ 。那么此时有三种情况： $nums[j] + nums[k] \u003c target$： 此时可以注意到，如果我们继续减小 $k$，直到$k = j + 1$，也不会遇到符合条件的结果。换句话说，对于当前 $j$ 而言，$k \\in [j+1, k]$ 不可能存在符合条件的结果。 $nums[j] + nums[k] \u003e target$： 此时可以注意到，如果我们继续增加 $j$，直到$j = k - 1$，也不会遇到符合条件的结果。换句话说，对于当前 $k$ 而言，$j \\in [j, k-1]$ 不可能存在符合条件的结果。 $nums[j] + nums[k] = target$： 此时符合条件，可以返回值。 因此我们可以得知，在区间 $[j, k]$ 内，对于情况 1，我们只需要继续搜索区间 $[j+1, k]$，而对于情况 2，我们也只需要继续搜索区间 $[j,k-1]$ 才可能会出现符合条件的结果。而对于情况 3，我们只需要继续搜索区间 $[j+1, k-1]$。无论怎样，经过一次计算，我们需要考虑的列表长度都会减少 1 或 2，这意味着 twoSum 的时间复杂度来到了 $\\mathcal{O}(n)$。 ","date":"2022-04-24","objectID":"/lc15/:3:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针代码 class Solution: def threeSum(self, nums: List[int]) -\u003e List[List[int]]: length = len(nums) nums.sort() res = [] for i in range(0, length - 2): if nums[i] \u003e 0: break if i \u003e 0 and nums[i] == nums[i - 1]: continue target = -nums[i] k = length - 1 j = i + 1 while k \u003e j: if nums[j] + nums[k] \u003e target: k -= 1 elif nums[j] + nums[k] \u003c target: j += 1 else: res.append([nums[i], nums[j], nums[k]]) k -= 1 j += 1 while k \u003e j and nums[k] == nums[k + 1]: k -= 1 while k \u003e j and nums[j] == nums[j - 1]: j += 1 return res 此处依旧有一些细节需要注意。对于 twoSum 部分，使用 while 循环来代替 for 循环可以极大的减少运行的时间，对于最外层循环，当 $nums[i] \u003e 0$ 时，无论 $j$ 和 $k$ 取何值，都无法得到 0，因此可以直接结束全部计算，这是因为数组已经经过了从大到小的排序。 总体来说，twoSum 部分时间复杂度为 $\\mathcal{O}(n)$，嵌套在外层循环中，整体时间复杂度为 $\\mathcal{O}(n^2)$，考虑到排序的时间复杂度为 $\\mathcal{O}(nlogn)$，因此整体时间复杂度依旧为 $\\mathcal{O}(n^2)$。与 hashmap 的解法相比，虽然时间复杂度相同，但是没有了排除重复项及 hashmap 的影响，最终结果得到了很好的提升。 执行用时: 436 ms，超过了 99% 的 Python 提交记录。 内存消耗: 17.8 MB，超过了 72% 的 Python 提交记录。 ","date":"2022-04-24","objectID":"/lc15/:4:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"最后 1% 注意到 $j$ 和 $k$ 的初值设置问题。由于列表有序，我们完全可以使用二分查找减少双指针最初无用的查找。Python 内置了 bisect 库，可以使用二分查找方便的生成列表中目标元素的索引。增加二分查找后，代码如下： # ······ k = length - 1 j = i + 1 if nums[j] + nums[k] \u003e target: k = bisect.bisect_right(nums, target - nums[j], j + 1, k) else: j = bisect.bisect_left(nums, target - nums[k], j, k - 1) # ······ 最终结果： 执行用时: 300 ms，超过了 100% 的 Python 提交记录。 内存消耗: 17.9 MB，超过了 53% 的 Python 提交记录。 同样的思路，双指针 + 二分查找可以用在 LC16 最接近的三数之和上。 问题链接：最接近的三数之和 附代码： class Solution: def threeSumClosest(self, nums: List[int], target: int) -\u003e int: res = 10 ** 4 sum = 0 need_ = 0 length = len(nums) if length == 3: return nums[0] + nums[1] + nums[2] nums.sort() for i in range(length - 2): need = target - nums[i] if i \u003e 0 and nums[i] == nums[i - 1]: continue if target \u003e 0 and need \u003c= 0: if abs(res - target) \u003e abs(nums[i] + nums[i + 1] + nums[i + 2] - target): res = nums[i] + nums[i + 1] + nums[i + 2] break j = i + 1 k = length - 1 if nums[j] + nums[k] \u003e need: k = bisect.bisect_right(nums, need - nums[j], i + 2, k) else: j = bisect.bisect_left(nums, need - nums[k], i + 1, k - 1) - 1 while j \u003c k: sum = nums[i] + nums[j] + nums[k] if abs(res - target) \u003e abs(sum - target): res = sum need_ = nums[j] + nums[k] if need_ \u003e need: k -= 1 while j \u003c k and nums[k] == nums[k + 1]: k -= 1 elif need_ \u003c need: j += 1 while j \u003c k and nums[j] == nums[j - 1]: j += 1 else: return target return res 执行用时: 32 ms，超过了 100% 的 Python 提交记录。 内存消耗: 15.2 MB，超过了 14% 的 Python 提交记录。 最后，100% 真好看。😎 ","date":"2022-04-24","objectID":"/lc15/:5:0","tags":["Python","双指针","二分查找"],"title":"LC15 - 三数之和","uri":"/lc15/"},{"categories":["leetcode"],"content":"双指针是好文明!","date":"2022-04-20","objectID":"/lc11/","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":" 问题链接：盛水最多的容器 ","date":"2022-04-20","objectID":"/lc11/:0:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"思考 易得：面积公式为 $S = (r - l) \\times min(height[r], height[l])$，$r$ 和 $l$ 分别为所选择两条线的序号。最容易想到的解决方式即为双循环，遍历所有可能的 $r$ 和 $l$ 的组合。 ","date":"2022-04-20","objectID":"/lc11/:1:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"代码 class Solution: def maxArea(self, height: List[int]) -\u003e int: maxS = 0 for r in range(1, len(height)): for l in range(0, len(height)): maxS = max(maxS, (r - l) * min(height[r], height[l])) return maxS 简单双循环代码，没有什么可解释的。 然而对于一道中等难度的题来说，这种解法实在是有些不能令人满意。实际上这段代码运行后会超时，Time Limit Exceeded，喜闻乐见的 TLE。 当然，我不会这么简单就放弃（这么简单的算法还是早点放弃得了）。将语言换成 C 后，代码如下： int maxArea(int* height, int heightSize){ int maxS = 0; for (int r = 1; r \u003c heightSize; r++) { bool Higher = false; int Highest = height[0]; for (int l = 0; l \u003c heightSize; l++) { if (height[l] \u003c= height[r]) { if (height[l] \u003e= Highest) { maxS = fmax(maxS, (r - l) * fmin(height[l], height[r])); Highest = height[l]; } } else { if (!Higher) { maxS = fmax(maxS, (r - l) * fmin(height[l], height[r])); Higher = true; } } } } return maxS; } 代码优化。 相较于 Python 的代码，这里又进行了一些优化。注意到在内循环（也即 $l$ 循环）的过程中，$l$ 值不断变大，意味着公式中 $(r - l)$ 的部分会不断变小。这里分为两个情况： $height[l]$ 比 $height[r]$ 更低： 此时容器的盛水量由 $height[l]$ 决定而不是 $height[r]$ 。当 $(r - l)$ 不断变小，这意味着我们需要找到更大的 $height[l]$ 才有可能计算处更大的盛水量 $S$。因此在内循环过程中，记录所碰到的 $height[l]$ 的最大值，仅当当前 $height[l]$ 值比历史最大值大时，才进行盛水量的计算，否则直接跳过这次循环。 $height[l]$ 比 $height[r]$ 高： 此时容器的盛水量由 $height[r]$ 决定，在内循环过程中，当 $l$ 不断变大，即 $(r - l)$ 不断变小，盛水量 $S$ 必定为不断减少。因此当 $height[l] \u003e height[r]$ 时，一次内循环仅需要计算第一次的盛水量，因为第二次、第三次等以后次数的盛水量必定小于第一次的盛水量。 在这样的优化条件下，代码依旧碰上了喜闻乐见的 TLE。事实证明 $\\mathcal{O}(n^2)$ 的算法在这种拙劣的优化下没有什么用处，该 $\\mathcal{O}(n^2)$ 还是 $\\mathcal{O}(n^2)$。 ","date":"2022-04-20","objectID":"/lc11/:2:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"双指针解法 换个思路。双重循环实际上就是双指针，右指针每次向右移动一位，而左指针每次从开始位置移动到右指针所在位置。这带来一个问题，注意到 $S = (r - l) \\times min(height[r], height[l])$ ，在内循环过程中，第一项始终不断变小，而当外循环每移动一次，第一项又会变大，这就导致我们需要重新将 $r$ 放置到初始位置，重新计算所有的可能结果。有没有一种方法能够让 $(r - l)$ 不断变小呢？这样我们只需要考虑 $min(height[r], height[l])$ 带来的变化。 考虑一个通常的情况：$l$ 和 $r$ 处在不同的位置并且相距一定的距离（注意到 $l$ 一定是小于 $r$ 的）。我们假设 $height[l]$ 比 $height[r]$ 更高。那么此时，我们的盛水量由 $height[r]$ 决定的。为了寻求更大的盛水量，我们有四种做法： 向右移动 $r$: 这样我们的 $(r - l)$ 会增大，并且有可能遇到更大的 $height[r]$ ，但若是碰到更小的$height[r]$ ，也需要一些计算，有利有弊。 向左移动 $r$: 这样我们的 $(r - l)$ 会减小，但可以去寻求更大的 $height[r]$，有利有弊。 向右移动 $l$: 这样我们的 $(r - l)$ 会减少，就算碰到更大的 $height[l]$ 也会因为 $height[r]$ 的限制在，不管怎么样都是亏。 向左移动 $l$: 这样我们的 $(r - l)$ 会增大，但是可能会碰到更小的 $height[l]$ ，有利有弊。 到这一步，应该考虑那种走法？注意到以上四种走法中，有一种走法比较特殊，即向右移动 $l$，也可以称为没有前途。 如果我们将 $l$ 值减1（即向右移动 $l$），那么 $(r - l)$ 的值会减小，$min(height[r], height[l])$ 的值也只会降低或不变，而不会增加（我们假设了 $height[l]$ 比 $height[r]$ 高）。 有趣的地方来了：如果我们在 $l$ 和 $r$ 相遇以前，不断地重复这个步骤，那么计算得到的 $S$ 肯定不会高于没有移动 $l$ 时的 $S$ ！ 事实上，这个结果就是我们之前导出结论的强化：参见本文代码章节优化部分，第二个情况， $height[l]$ 比 $height[r]$ 高。这样一来，意味着我们可以跳过本轮内循环，开始下一轮内循环。这是因为就算我们继续计算下去，$S$ 也只会变低而不会变高。 如果按照往常（双循环）的思路，接下来我们应该向右移动 $r$ ，当然这又会导致上述的问题。这里我们换一个思路：这里我们已经计算出在 $[l, r]$ 区间内固定住 $r$ 后，$l$ 在所有不同位置处时 $S$ 的最大值，也就是我们已经考虑完了 $r$ 对 $l \\in [l, r - 1]$ 所有的可能性，进一步的，当 $r$ 和 $l$ 分别是列表的两个端点时，我们就不需要再考虑更多的问题。换句话说，为了穷举所有的可能性，我们现在只需要计算 $[l, r - 1]$ 这个区间中所有的可能 $S$。也就是说，我们仅仅通过一次比较和计算，就让输入列表的长度从 $n$ 下降到了 $n-1$。 当然你可能会问，这样做的前提是我们的假设 $height[l]$ 比 $height[r]$ 更高啊？事实上，当 $height[l]$ 比 $height[r]$ 低时，我们得到的新列表为$[l + 1, r]$ 。 那么聪明如你肯定就已经明白了问题解决的办法，只要我们不断重复上面的操作，我们就可以在 $\\mathcal{O}(n)$ 列举出所有的可能的 $S$，并且通过比较得出最终结果了。 本段描写更加偏向于对双指针思考的思路和证明，比较抽象。更为具体的描述相信网上随处可见。 事实上我认为双指针从中间往两边扩散也是可行的？那么扩散的初试条件是什么？这个有待进一步思考。 ","date":"2022-04-20","objectID":"/lc11/:3:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"双指针解法代码 int maxArea(int* height, int heightSize){ int minH = 0; int maxS = 0; int maxS_ = 0; int l = 0; int r = heightSize - 1; int maxL = height[l]; int maxR = height[r]; while (r \u003e l) { if (maxL \u003e maxR) { // 两数之中取其小 minH = maxR; } else { minH = maxL; } maxS_ = (r - l) * minH; // 临时盛水量 if (maxS_ \u003e maxS) { // 两数之中取其大 maxS = maxS_; } while (r \u003e l){ if (height[r] \u003e= height[l]) { l++; if (height[l] \u003e maxL) { maxL = height[l]; break; } } else { r--; if (height[r] \u003e maxR) { maxR = height[r]; break; } } } } return maxS; } 这里同样引入了一个小小改进。在 $(r-l)$ 不断减小的情况下，只有更大的 $height$ 才可能计算出更大的 $S$。因此在运行过程中记录碰到的最大的 $height[l]$ 和 $height[r]$，通过引入比较，来进一步减少计算的次数。同样的，这是本文代码章节优化部分，第一个情况， $height[l]$ 比 $height[r]$ 低部分思路的引用。 在代码中，我最开始采用了内置函数 fmax 和 fmin ，无论执行用时和内存消耗都很高。自定义 max 函数可以减少一部分内存消耗，但是最佳的做法还是简单 if 语句。 最终结果为： 执行用时: 76 ms，超过了 88% 的 c 提交记录。 内存消耗: 11.4 MB，超过了 67% 的 c 提交记录。 ","date":"2022-04-20","objectID":"/lc11/:4:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["leetcode"],"content":"结尾碎碎念 现在时间是2:37，原本只想随便写写，结果越写越多。这同样是一个梳理自己思路的过程，很多不清晰的事情，如果不加以思考，是很难落笔的。第一次写关于技术细节的文章，只能说比写浅入浅出教程有意义多了。 下一步学学怎么画图，图解还是非常重要的。有时间把 LC10 正则匹配也记录一下，用到了动态规划，也非常有用。 夜深了，该洗洗衣服睡觉了。 ","date":"2022-04-20","objectID":"/lc11/:5:0","tags":["C","Python","双指针"],"title":"LC11 - 盛水最多的容器","uri":"/lc11/"},{"categories":["AI"],"content":"简单记录下毕业设计的内容，以及解决问题的历程。","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":" 《基于人工智能的大气重点污染物浓度预测》 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:0:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"毕设灵感 很久之前，我就有将循环神经网络用在大气污染物浓度预测上的想法，可以自由选择题目的课程设计也就成了实现这个想法最好的平台。最初的想法非常简单：随便找几个监测站的大气污染物数据，把别人写好的 LSTM、GRU 之类的模型拿来用一用，再随便拟合一下就算大功告成。 考研初试结束后，我也总算有了一些时间继续做一些自己喜欢的工作。在学习的过程中，我发现了一个以前没有注意到过的领域 — 视频预测(Video Prediction)领域。这个方向的问题大概为：输入一个视频的前几帧，让你去预测下一帧的图像。针对这个领域的问题，非常具有代表性的一个工作就是 ConvLSTM，这是一篇NIPS2015的论文，讲的是利用 CNN 和 LSTM 结合，通过前几帧的卫星图像，来预测以后的卫星图像，进而对降水进行预测。我忽然意识到，如果将大气污染物的浓度分布作为原始输入，不也可以预测未来的污染物浓度分布吗？ 这激起了我的好奇心，检索了一下相关的工作，有一篇上海交大的硕士毕业论文完成了这项工作，作者使用的就是原始的 ConvLSTM。事实上，从 ConvLSTM 出现至今，视频理解方向的工作已经有了很多进步，从 Papers with Code 的网站上就可以看到。但是这些变化，还没有应用到大气污染物预测的领域，作为一个专业的学术易拉罐，这样的好机会我是不会放过的。 就这样，毕设难度一下子顶了上去，从原本的浓度单点预测，变成了现在的浓度分度预测。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:1:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"实验推进 深度学习，模型、数据、计算资源缺一不可。 模型方面，目前实现了 ConvLSTM 和 ConvGRU 两个模型，打算最后要是有时间还可以再做一下 Transformer 的结合，虽然说大概率没希望，因为数据量太少了，难以支撑起 Transformer 的效果。 数据方面，我原本想要自己安装一下 WRF-Chem 来跑些训练数据出来，先是根本找不到 WRF-Chem 完整的学习资料，导致安装摸爬滚打完之后，连软件该怎么运行都搞不清楚；后是排放清单数据拿不到，最终只好搁置了这个计划。转头去找学姐发文时用的数据，终于找到了大概有 550 多条数据，数据量堪忧。 计算资源方面，目前只有我寝室使用的 1050Ti。 总之就是前途非常渺茫。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"模型实现 代码仓库：DL_PM_Pred，公式如下： ConvLSTM $$ I_{t} = Sigmoid(Conv(X_t, W_{xi}) + Conv(H_{t-1}, W_{hi}) + b_i) \\\\ F_{t} = Sigmoid(Conv(X_t, W_{xf}) + Conv(H_{t-1}, W_{hf}) + b_f) \\\\ O_{t} = Sigmoid(Conv(X_t, W_{xo}) + Conv(H_{t-1}, W_{ho}) + b_o) \\\\ \\tilde{C_t} = Tanh(Conv(X_t, W*{xc}) + Conv(H_{t-1}, W_{hc}) + b_h) \\\\ C_t = F_t \\odot C_{t-1} + I_t \\odot \\tilde{C_t} \\\\ H_t = O_t \\odot Tanh(C_t)\\\\ Pred = ReLU(Conv(X_t, W*{xx}) + Conv(H_t, W_{xh}) + b_{p}) \\\\ $$ ConvGRU $$ R_{t} = Sigmoid(Conv(X_t, W_{xr}) + Conv(H_{t-1}, W_{hr})+b_r) \\\\ Z_{t} = Sigmoid(Conv(X_t, W_{xz}) + Conv(H_{t-1}, W_{hz})+b_z) \\\\ \\tilde{H_t} = Tanh(Conv(X_t, W*{xh})+Conv(R_t \\odot H_{t-1}, W_{rh}) + b_{h}) \\\\ H_t = Z_t \\odot H_{t-1} + (1 - Z_t) \\odot \\tilde{H} \\\\ Pred = ReLU(Conv(X_t, W_{xx}) + Conv(H_t, W_{xh}) + b_{p}) \\\\ $$ ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:1","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"数据分析 模拟范围 模拟范围如图： ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:2","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"变量选择 解包 wrfout 文件后，文件保存了 281 个变量，分别是： ['Times', 'XLAT', 'XLONG', 'LU_INDEX', 'ZNU', 'ZNW', 'ZS', 'DZS', 'VAR_SSO', 'U', 'V', 'W', 'PH', 'PHB', 'T', 'HFX_FORCE', 'LH_FORCE', 'TSK_FORCE', 'HFX_FORCE_TEND', 'LH_FORCE_TEND', 'TSK_FORCE_TEND', 'MU', 'MUB', 'NEST_POS', 'P', 'PB', 'FNM', 'FNP', 'RDNW', 'RDN', 'DNW', 'DN', 'CFN', 'CFN1', 'THIS_IS_AN_IDEAL_RUN', 'P_HYD', 'Q2', 'T2', 'TH2', 'PSFC', 'U10', 'V10', 'RDX', 'RDY', 'RESM', 'ZETATOP', 'CF1', 'CF2', 'CF3', 'ITIMESTEP', 'XTIME', 'QVAPOR', 'QCLOUD', 'QRAIN', 'QICE', 'QSNOW', 'QGRAUP', 'SHDMAX', 'SHDMIN', 'SNOALB', 'TSLB', 'SMOIS', 'SH2O', 'SMCREL', 'SEAICE', 'XICEM', 'SFROFF', 'UDROFF', 'IVGTYP', 'ISLTYP', 'VEGFRA', 'GRDFLX', 'ACGRDFLX', 'ACSNOM', 'SNOW', 'SNOWH', 'CANWAT', 'SSTSK', 'COSZEN', 'LAI', 'VAR', 'MAPFAC_M', 'MAPFAC_U', 'MAPFAC_V', 'MAPFAC_MX', 'MAPFAC_MY', 'MAPFAC_UX', 'MAPFAC_UY', 'MAPFAC_VX', 'MF_VX_INV', 'MAPFAC_VY', 'F', 'E', 'SINALPHA', 'COSALPHA', 'HGT', 'TSK', 'P_TOP', 'T00', 'P00', 'TLP', 'TISO', 'TLP_STRAT', 'P_STRAT', 'MAX_MSTFX', 'MAX_MSTFY', 'RAINC', 'RAINSH', 'RAINNC', 'SNOWNC', 'GRAUPELNC', 'HAILNC', 'CLDFRA', 'SWDOWN', 'GLW', 'SWNORM', 'OLR', 'XLAT_U', 'XLONG_U', 'XLAT_V', 'XLONG_V', 'ALBEDO', 'CLAT', 'ALBBCK', 'EMISS', 'NOAHRES', 'TMN', 'XLAND', 'UST', 'PBLH', 'HFX', 'QFX', 'LH', 'ACHFX', 'ACLHF', 'SNOWC', 'SR', 'SAVE_TOPO_FROM_REAL', 'EROD', 'CLDFRA2', 'RAINPROD', 'EVAPPROD', 'UST_T', 'ROUGH_COR', 'SMOIS_COR', 'DUSTLOAD_1', 'DUSTLOAD_2', 'DUSTLOAD_3', 'DUSTLOAD_4', 'DUSTLOAD_5', 'DRYDEPVEL', 'GRASET_1', 'GRASET_2', 'GRASET_3', 'GRASET_4', 'GRASET_5', 'DRYDEP_1', 'DRYDEP_2', 'DRYDEP_3', 'DRYDEP_4', 'DRYDEP_5', 'EDUST1', 'EDUST2', 'EDUST3', 'EDUST4', 'EDUST5', 'DRY_DEP_LEN', 'DRY_DEP_FLUX', 'WET_DEP_FLUX', 'EBIO_ISO', 'EBIO_API', 'LAI_VEGMASK', 'dvel_o3', 'PM2_5_DRY', 'PM10', 'DMS_0', 'PHOTR201', 'PHOTR202', 'PHOTR203', 'so2', 'sulf', 'no2', 'no', 'o3', 'hno3', 'h2o2', 'ald', 'hcho', 'op1', 'op2', 'paa', 'ora1', 'ora2', 'nh3', 'n2o5', 'no3', 'pan', 'hc3', 'hc5', 'hc8', 'eth', 'co', 'ol2', 'olt', 'oli', 'tol', 'xyl', 'aco3', 'tpan', 'hono', 'hno4', 'ket', 'gly', 'mgly', 'dcb', 'onit', 'csl', 'iso', 'hcl', 'ho', 'ho2', 'so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'naaj', 'naai', 'claj', 'clai', 'orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgba1j', 'orgba1i', 'orgba2j', 'orgba2i', 'orgba3j', 'orgba3i', 'orgba4j', 'orgba4i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha', 'seas', 'soila', 'nu0', 'ac0', 'corn', 'ISEEDARR_SPPT', 'ISEEDARR_SKEBS', 'ISEEDARR_RAND_PERTURB', 'ISEEDARRAY_SPP_CONV', 'ISEEDARRAY_SPP_PBL', 'ISEEDARRAY_SPP_LSM', 'BF', 'C1H', 'C2H', 'BH', 'C1F', 'C2F', 'C3H', 'C4H', 'C3F', 'C4F', 'PCB', 'PC', 'LANDMASK', 'LAKEMASK', 'SST', 'SST_INPUT'] 数据量相当夸张。为了减轻渣渣 1050Ti 的压力，需要从这些变量中选出主要变量。从这些变量中找出对 PM 影响较大的变量不是一件容易的事情，这里首先从数据的 shape 入手，将 shape 不是四维的数据首先排除可能，经筛选后，变量名、描述及翻译如下： 变量名 描述 翻译 U x-wind component x 轴风分量 V y-wind component y 轴风分量 W z-wind component z 轴风分量 PH perturbation geopotential 摄动位势高度 PHB base-state geopotential 基态位势高度 T perturbation potential temperature (theta-t0) 摄动势温 P perturbation pressure 摄动压 PB BASE STATE PRESSURE 基态压力 P_HYD hydrostatic pressure 流体静压 QVAPOR Water vapor mixing ratio 水汽混合比 QCLOUD Cloud water mixing ratio 云水混合比 QRAIN Rain water mixing ratio 雨水混合比 QICE Ice mixing ratio 冰混合比 QSNOW Snow mixing ratio 雪混合比 QGRAUP Graupel mixing ratio 霰粒混合比 TSLB SOIL TEMPERATURE 土壤温度 SMOIS SOIL MOISTURE 土壤湿度 SH2O SOIL LIQUID WATER 土壤液态水 SMCREL RELATIVE SOIL MOISTURE 相对土壤水分 CLDFRA CLOUD FRACTION 云分数 EROD fraction of erodible surface in each grid cell 每个网格单元中可侵蚀表面的分数 CLDFRA2 CLOUD FRACTION 云分数 RAINPROD TOTAL RAIN PRODUCTION RATE 总降雨率 EVAPPROD RAIN EVAPORATION RATE 降雨蒸发率 EDUST1 DUST emissions bin1 粉尘排放 EDUST2 DUST emissions bin2 粉尘排放 EDUST3 DUST emissions bin3 粉尘排放 EDUST4 DUST emissions bin4 粉尘排放 EDUST5 DUST emissions bin5 粉尘排放 DRY_DEP_LEN dry deposition velocity 干沉降速率 DRY_DEP_FLUX dry deposition flux 干沉降通量 WET_DEP_FLUX column wet scavening flux 柱湿清除通量 dvel_o3 O3 deposit","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:3","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"预实验 默认实验条件如下： 变量名 值 Model ConvGRU Learning Rate 0.0005 Batch Size 4 Kernel Size 5 Number of Epochs 200 Number of Steps 5 Number of Layers 3 Random Iter True Weight Decay 0 预实验 1 预实验 1 的目的是确定变量的选择。有两个方案可供选择： 方案 1 变量为全部的非零变量中去重后的变量，总计 78 个变量，变量名如下： key = ['PM10', 'PM2_5_DRY', 'U', 'V', 'QVAPOR','CLDFRA','QRAIN','QICE','QSNOW','QGRAUP','CLDFRA','so2','sulf','no2', 'no','o3','hno3','h2o2','ald','hcho','op1','op2','paa','ora1','ora2','nh3','n2o5','no3','pan','hc3','hc5','hc8','eth','co','ol2','olt','oli','tol','xyl','aco3','tpan','hono','hno4','ket','gly','mgly','dcb','onit','csl','iso','hcl','ho','ho2','so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'naaj','naai','claj','clai','orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha'] 实验结果如下： 方案 2 变量为上述 78 个变量中按照变量描述选择的 30 个变量： key = ['PM10', 'PM2_5_DRY', 'U', 'V', 'QVAPOR','CLDFRA','so2','no2', 'no','so4aj', 'so4ai', 'nh4aj', 'nh4ai', 'no3aj', 'no3ai', 'orgaro1j', 'orgaro1i', 'orgaro2j', 'orgaro2i', 'orgalk1j', 'orgalk1i', 'orgole1j', 'orgole1i', 'orgpaj', 'orgpai', 'ecj', 'eci', 'p25j', 'p25i', 'antha'] 实验结果如下： 结论 可以看出所选的 30 个变量效果甚至优于 78 个变量。因此后续实验以 30 变量进行。猜测这是因为选择的 30 个变量中已经包含了预测 PM 所需的大部分信息。 预实验 2 预实验 2 讨论的问题为训练当中的两个 MSE 尖峰是如何产生的，猜测原因为数据中存在时序上不连续的数据。减少数据量，选择时序上一直连续的数据，进行实验： 发现不存在尖峰且效果良好，因此增加去除非时序连续数据代码，恢复数据量，重新实验： 结论 可以看出尖峰的出现的确与数据时序不连贯有关，但尖峰依旧存在，猜测这是因为在优化的过程中出现了训练集上的局部过拟合。解决方法一般为增加 Batch Size，但是由于硬件原因不能实现。此处尝试增加正则化手段减少过拟合。 预实验 3 预实验 3 讨论的问题为 Batch Normalization 的作用。添加 BN 层，进行试验： 结论 效果提升显著并且不再出现 MSE 上升，证明了上述猜测。因此后续采用带有 Batch Normalization 的网络。并且本次实验结果作为实验的基准效果。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:4","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"实验 基准实验 基准实验的参数选择如下： 变量名 值 Model ConvGRU Batch Size 4 Kernel Size 5 Number of Steps 5 Weight Decay 0 实验效果： 实验 1 实验 1 讨论的问题为 Weigth Decay 的影响。当 Weigth_Decay 为 1e-4 时： 当 Weight_Decay = 1e-5 时： 当 Weight_Decay = 1e-6 时： 结论 可以看出 Weigth_Decay 确实对过拟合有一定程度的缓和，但总体影响不大。 实验 2 实验 2 主要的讨论目标为 Kernel_Size 对训练效果的影响。当降低 Kernel_Size 为 4 时： 当增加 Kernel_Size 为 7 时： 结论 可以看出，减小 Kernel_Size 后，模型泛化能力下降，增加 Kernel_Size 后，模型过拟合现象更加严重。 实验 3 实验 3 主要讨论的影响因素为 Batch_Size 对训练效果的影响。当减小 Batch_Size 到 2 时： 当增加 Batch_Size 到 6 时： 结论 可以看出，增加或减小 Batch_Size 并没有明显影响。 实验 4 实验 4 的目的为探究 Num_Steps 对训练效果的影响。当减小 Num_Steps 到 3 时： 当增加 Num_Steps 到 7 时： 结论 可以看出，增加 Num_Steps 加剧了过拟合现象，减小 Num_Steps 降低了模型的泛化能力。 实验 5 实验 5 的目的为探究 ConvLSTM 的效果。当将模型切换为 ConvLSTM 后： 结论 可以看出模型泛化能力下降。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:5","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"总结 在上述的实验中，可以得出： Batch Size 对网络训练效果影响不大； Weigth Decay 的引入可以提升网络的泛化能力； Kernel Size、Num Steps 的增加会加剧网络过拟合，其减小又会引发泛化能力的下降； 相较于 ConvLSTM，ConvGRU 具有更好的泛化能力。 问题 事实上，上述实验结果的导出十分具有局限性。因为最后实验数据仅仅整理出 166 条训练集数据及 55 条测试集数据。在深度学习领域，这样的数据量是极小的。并且值得注意的是，训练集数据并没有分布在测试数据所在的时间段上，这也是训练集效果良好，测试集效果差距较大的原因之一。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:2:6","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"绘图 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:3:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["AI"],"content":"工作时间线 2022/04/21及之前：完成了模型训练、预测的代码。 2022/04/22：从实验室区筛选了带有 PM 的 WRF 数据，大概有550条。 2022/04/23：确认数据，筛选合适的数据。最终数据分布在 3 个时间段上，共计 221 条。 2022/04/25：训练一部分数据，训练集 MSELoss 为 12.6。 2022/05/01：实验完成。 2022/05/08：画个图。 ","date":"2022-04-20","objectID":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/:4:0","tags":["WRF","Python"],"title":"杂谈毕业设计","uri":"/%E6%9D%82%E8%B0%88%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"categories":["教程"],"content":"为了做毕设，这两天被 WRF 折磨的头疼了不少时间。网络上找到的教程往往是支离破碎，一人一个说法；WRF-Chem 官方教程又因为网络问题看不得，只能自己摸着石头过河。在此处记录一份完整的 WRF 安装教程，免得重蹈覆辙。","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":" 猴子都能懂的 WRF 教程，简称猴懂 WRF。 提示 如有问题欢迎与我联系😀 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:0:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"在这之前 在安装 WRF(The Weather Research and Forecasting Model) 之前，请先确定你的需求。比如要使用 WRF 来预测 PM ，这就要求你应当安装 WRF-Chem 而不仅仅是 WRF 。 本文内容包含 WRF 及 WRF-Chem 的编译。 有关 WRF-Chem 运行的部分，请参考 WRF-Chem User’s Guide。 在 WRF 官网有提供一个非常友善的 WRF 编译教程，但是该教程编译只包含 WRF 的部分，而且使用了 tcsh，与现在比较流行的 bash 可能会有一些出入。 有繁琐工作的地方就有自动化脚本，当然包括 WRF-Chem 的安装。这里也推荐我在Gitee上发现的一个全自动安装脚本，直接免除下面的所有工作，你仅仅需要根据自己的需求对脚本做一些简单的修改即可。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:1:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"平台准备 WRF 模型仅能运行在 Linux 系统上。为此，你可能需要： 一台安装了 Linux 系统的电脑 带有 Linux 系统的虚拟机 WSL(Windows Subsystem Linux) 中的其中一种方式来使用 Linux 系统。如果你的操作系统是 Windows 10 或者 Windows 11，那么 WSL 可能是一个最佳的选择。WSL 的安装可以参考微软官方的教程。本文中使用的系统为 Windows11 下的 WSL，安装的系统为 Ubuntu 20.04。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:2:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"文件下载及环境准备 首先要准备 WRF 和 WPS(WRF Pre-Processing System) 的安装文件 ，这两个程序的最新版本可以在 GitHub 很容易的下载下来，现在你需要新建一个文件夹，把 WRF 和 WPS 放在同一文件夹内（这个文件夹将会成为你放置 WRF 和 WPS 程序的文件夹），并将它们解压。对于 zip 类型的压缩包，你可以使用 unzip 命令来解压缩；对于 tar.gz 类型的压缩包，你需要使用 tar xzvf 命令来解压缩。 接下来，你可能需要安装一些编译器。编译 WRF 需要三个编译器，分别是 gfortran 、 cpp 和 gcc。你可以分别使用命令 which gfortran 、 which cpp 和 which gcc 来检查你的环境中是否包含这三个编译器，对于包含编译器的环境，which 命令将会返回对应地址，如果 which 命令没有任何反应，你可能需要手动安装这些编译器。不同的操作系统可能会有所差异，对于 Ubuntu 来说，你只需要运行 sudo apt-get install gfortran 来安装 gfortran 编译器，其它缺失的编译器同理。 除了三个编译器之外，你可能还需要安装 csh 和 perl 。你同样可以通过 sudo apt-get install 命令来安装它们。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:3:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"依赖库 在这里，你需要安装 5 个与 WRF 运行有关的库，分别是： mpich-3.0.4 netcdf-4.1.3 jasper-1.900.1 libpng-1.2.50 zlib-1.2.7 你可以通过点击上述链接，下载库的源代码。现在进入到放置 WRF 和 WPS 的文件夹中，在该文件夹内新建名为 Bulid_WRF 的文件夹，并在该文件夹内新建名为 LIBRARIES 的文件夹。将这些程序在 LIBRARIES 文件夹中逐一解压。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"添加环境变量 在进行以下的操作前，请先在终端（ bash ）中运行下面的代码来添加环境变量： export DIR=$HOME/software/Build_WRF/LIBRARIES # 请修改此条为你的 LIBRARIES 文件夹路径 export WRF_DIR=$HOME/software/WRF-4.3.3/ # 请修改此条为你解压 WRF 后文件夹的路径 export CC=gcc export CXX=g++ export FC=gfortran export FCFLAGS=-m64 export F77=gfortran export FFLAGS=-m64 export JASPERLIB=$DIR/grib2/lib export JASPERINC=$DIR/grib2/include export LDFLAGS=-L$DIR/grib2/lib export CPPFLAGS=-I$DIR/grib2/include export PATH=$DIR/mpich/bin:$PATH export PATH=$DIR/netcdf/bin:$PATH export NETCDF=$DIR/netcdf ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:1","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"mpich mpich 是并行计算所需要的库，你可以运行以下的代码来安装： cd mpich-3.0.4 # 进入解压后的 mpich-3.0.4 文件夹 ./configure --prefix=$DIR/mpich make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:2","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"netCDF netCDF 是编译 WRF 所需要的数据格式库，你可以通过运行以下的代码来安装： cd netcdf-4.1.3 # 进入解压后的 netcdf-4.1.3 文件夹 ./configure --prefix=$DIR/netcdf --disable-dap --disable-netcdf-4 --disable-shared make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:3","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"zlib 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd zlib-1.2.7 ./configure --prefix=$DIR/grib2 make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:4","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"libpng 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd libpng-1.2.50 ./configure --prefix=$DIR/grib2 make make install ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:5","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"Jasper 编译 WPS 所需的库，你可以通过运行以下的代码来安装： cd jasper-1.900.1 ./configure --prefix=$DIR/grib2 make make install 请按照上述顺序来安装以避免预料之外的错误。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:6","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"WRF-Chem 对 WRF-Chem 来说，这里还需要一些额外的步骤。对于 WRF4 以下的版本，你可能需要下载单独的 WRF-Chem 编译所需的文件，并将这些文件解压到你的 WRF 文件夹内的 chem 文件夹中。对于 WRF4 以后的版本，则不需要进行此操作。 为了编译 WRF-Chem，这里需要添加一些环境变量： export WRF_EM_CORE=1 export WRF_NMM_CORE=0 export WRF_CHEM=1 export WRF_KPP=1 export YACC='/usr/bin/yacc -d' export FLEX=/usr/bin/flex export FLEX_LIB_DIR=/usr/lib/x86_64-linux-gnu/ export KPP_HOME=$HOME/software/WRF-4.3.3/chem/KPP/kpp/kpp-2.1 export WRF_SRC_ROOT_DIR=$HOME/software/WRF-4.3.3 export PATH=$KPP_HOME/bin:$PATH export SED=/usr/bin/sed export WRFIO_NCD_LARGE_FILE_SUPPORT=1 然后安装两个额外的库： sudo apt-get install yacc flex ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:4:7","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"编译 WRF 进入解压好的 WRF 文件夹，然后运行： ./configure 在这里你将会看到非常多不同的编译选项，一般选择 34 即可，这表示你使用 gcc 分布式并行编译 WRF。接下来，对于 nesting，直接选择默认选项即可。 接下来就可以对 WRF 进行编译，在此处你可以选择你想使用的 WRF 运行类型，有以下选项可以选择： em_real (三维真实情况) em_quarter_ss (三维理想状况) em_b_wave (三维理想状况) em_les (三维理想状况) em_heldsuarez (三维理想状况) em_tropical_cyclone (三维理想状况) em_hill2d_x (二维理想状况) em_squall2d_x (二维理想状况) em_squall2d_y (二维理想状况) em_grav2d_x (二维理想状况) em_seabreeze2d_x (二维理想状况) em_scm_xy (一维理想状况) 你可以根据自己的需求来选择编译哪个选项。一般应当选择 em_real 进行编译，以此为例，你应当运行： ./compile em_real 编译需要花费一段时间，对于 WRF，这可能会花费 30 分钟的时间，对于 WRF-Chem，编译可能需要 1 个小时。编译成功后，运行： ls -s main/*.exe 根据你编译选项的不同，你将会看到数个 .exe 文件。对于 em_real 选项，这四个文件分别是： wrf.exe real.exe ndown.exe tc.exe ⚠ 如果你编译失败，需要重新开始编译，请在重新执行本步骤前执行 ./clean。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:5:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":["教程"],"content":"编译 WPS 进入解压后的 WPS 文件夹，然后执行: ./configure 这里你依旧会看到不同的编译选项，一般来说，此处应当选择 3 号选项。请注意，这里的编译选项应当和编译 WRF 时的选项一致，尽管序号可能有所不同。接下来就可以对 WPS 进行编译，执行： ./compile 这可能会花费一段时间，执行成功后，输入 ls -s *.exe，将会看到三个 .exe 文件，分别是：geogrid.exe，ungrib.exe 和 metgrid.exe。 至此，所有的编译工作已经完成。如果有时间，我会考虑增加： WPS 的运行 WRF 的运行 wrfout 数据的处理 等内容。 ","date":"2022-04-20","objectID":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/:6:0","tags":["WRF"],"title":"浅入浅出 WRF 教程","uri":"/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BAwrf%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"嗦 嗨 嗨！-\u003e 害 嗨 嗨！","date":"2022-04-19","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":" 嗟乎！时运不齐，命途多舛。冯唐易老，李广难封。屈贾谊于长沙，非无圣主；窜梁鸿于海曲，岂乏明时？所赖君子见机，达人知命。老当益壮，宁移白首之心？穷且益坚，不坠青云之志。酌贪泉而觉爽，处涸辙以犹欢。北海虽赊，扶摇可接；东隅已逝，桑榆非晚。孟尝高洁，空余报国之情；阮籍猖狂，岂效穷途之哭！ ——《滕王阁序》，王勃 ","date":"2022-04-19","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"简介 😀 本人是一个跨考计算机二战的三非院校四大天坑本科毕业生，最近正在复习考研。 ","date":"2022-04-19","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"与我联系 📫 邮箱: blathers23@outlook.com 🐱 LeetCode 主页: @susasasa 👾 GitHub 主页: @blathers23 🦊 GitLab 主页: @blathers23 ","date":"2022-04-19","objectID":"/about/:1:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"动态 ","date":"2022-04-19","objectID":"/about/:2:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"进行中： 二战复习。(Jul 2022 - Present) 数据结构及算法。(Jul 2022 - Present) ","date":"2022-04-19","objectID":"/about/:2:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"搁置中： 刷LeetCode，学学算法，提高编程技术；考研复习期间暂且搁置。(Apr 2022 - Jun 2022) 浅读CSAPP，学习计算机组成原理及C语言编程基础；好多地方看不懂怎么说怎么说。(Jun 2022 - Jul 2022) ","date":"2022-04-19","objectID":"/about/:2:2","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"已完成： 毕业设计，基于Conv-GRU的大气颗粒物污染预测。(Apr 2022 - Jun 2022) ","date":"2022-04-19","objectID":"/about/:2:3","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"已弃坑： 将环境切换到Ubuntu来学习Linux；再次与Windows达成和解，日常使用Linux确实不方便，如有需求还是WSL。(May 2022 - Jul 2022) ","date":"2022-04-19","objectID":"/about/:2:4","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"关于本站 ","date":"2022-04-19","objectID":"/about/:3:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"写 Blog 的想法 就在建站的约摸两周前，一战跨考计算机最终宣告失败，最主要的因素还是准备不足。在回顾考研这一年来碰壁原因的时候，我意识到，很多知识之所以自己不能学以致用，其原因往往还是用的太少，正所谓眼高手低，又或者说talk is cheap。纸上得来终觉浅，绝知此事要躬行。 建立本站，通过将思维落实成文字的方式来加强自己的理解，我认为会是一种很有效的方式。 凝眸即久，欣然提笔，人在一种甜美的兴奋和平时没有的的敏锐之中，这样的时候，真是虽南面王不与易也。写成之后，提刀却立，四顾踌躇，对自己说：“你小子还真有两下子！”此乐非局外人所能想象。 ——《生活，是很好玩的》，汪曾祺 ","date":"2022-04-19","objectID":"/about/:3:1","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"施工时间线 😎 2022/04/19 Hello Hugo! 🥱 2022/04/22 页面施工基本完毕，等待上线。 😛 2022/04/22 正式上线 GitHub Pages! ✈️ 2022/04/25 迁移至 netlify! 🦊 2022/05/05 仓库迁移至 GitLab! ","date":"2022-04-19","objectID":"/about/:3:2","tags":null,"title":"关于","uri":"/about/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 😧博主理解粗浅，如有错误还请包涵，或联系博主订正 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:0:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅰ. 安装 MSYS2 博主选择使用 MSYS2 管理 g++ 的版本，有关 MSYS2 的介绍请参照此处。 首先安装 MSYS2。这里使用清华大学的镜像站 在安装过程中，可能会碰到安装进度卡在 66% 的情况，这时候我们取消安装再重新打开安装程序安装到原位置即可。 安装完成后我们为 MSYS2 配置清华镜像，提高下载的速度和稳定性，同样按照镜像站中的教程操作。 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:1:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅱ. 下载 g++ 和 gdb 首先更新核心软件包，运行指令： pacman -Syu 最后安装 g++，运行指令： pacman -S gcc 然后下载 gdb，运行指令： pacman -S mingw-w64-x86_64-gdb ","date":"2021-03-14","objectID":"/vscode_and_msys2/:2:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅲ. 配置环境变量 将 MSYS2 安装地址下的 \\usr\\bin 加入到Path变量。然后启动 powershell，输入指令 g++ -v检查安装是否成功。 如果使用 everything 搜索 g++.exe 是搜索不到 \\usr\\bin 文件夹中的，就算它就在文件夹里面。 ","date":"2021-03-14","objectID":"/vscode_and_msys2/:3:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"Ⅳ. 配置 VSCode 在 VSCode 扩展商店中搜索 C++，然后安装此扩展： 打开一个 C++ 语言程序，然后在 VSCode 中运行，此时会弹出环境选择框，这里我们选择 GDB，即第一项： 然后选择 g++ 进行编译，此时会报错，显示 miDebuggerPath 不存在： 这里我们编辑这一项，刚刚在第二步，我们下载了 gdb，其安装位置在 \\mingw64\\bin 下，于是我们将这一行改为： 保存，就可以愉快的使用快捷键调试辣👏！ ","date":"2021-03-14","objectID":"/vscode_and_msys2/:4:0","tags":["Cpp","VSCode"],"title":"VSCode 搭配 g++ 配置 Cpp 编译环境","uri":"/vscode_and_msys2/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 ✍️ go verison 1.15.8 使用 VSCODE 配置 go 开发环境时遇到了一些问题，主要是无法下载 Go modules，这里简要记一下配置方法（ Windows 系统）： ","date":"2021-02-13","objectID":"/golang_hello_world/:0:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"1. GO111MODULE ","date":"2021-02-13","objectID":"/golang_hello_world/:1:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"环境变量方法： 打开环境变量，为用户新建环境变量，变量名为 GO111MODULE，变量值为 on。 ","date":"2021-02-13","objectID":"/golang_hello_world/:1:1","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"命令方法： go env -w GO111MODULE='on' 两种方法取其一即可。 ","date":"2021-02-13","objectID":"/golang_hello_world/:1:2","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"2. GOPROXY 此处博主比较了 goproxy.io、阿里云镜像、goproxy.cn 三家镜像代理服务，博主自测 goproxy.cn 效果最佳。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"环境变量方法： 打开环境变量，为用户新建环境变量，变量名为 GOPROXY，变量值为 https://goproxy.cn,direct。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:1","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"命令方法： go env -w GOPROXY='https://goproxy.cn,direct' 两种方法取其一即可。 ","date":"2021-02-13","objectID":"/golang_hello_world/:2:2","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"3.go.mod 在代码调试前，还需要在命令行中执行 go mod init ****.go，****处为模块名称。 ","date":"2021-02-13","objectID":"/golang_hello_world/:3:0","tags":["Golang"],"title":"Golang - Hello World!","uri":"/golang_hello_world/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 ✍️ Gitalk版本 1.7.0；Gridea版本 0.9.2。 使用 Gridea 配置 Gitalk 功能，进入网页，登录 GitHub 提示 403 错误。这是由于 Gitalk 使用的反向代理网站在 2021 年 1 月 31 日起开始限制使用。参照这篇文章，总结 Gridea 的解决方式如下（博主使用了 Windows 系统）： 使用 everything 搜索 gitalk.ejs 可以找到如下文件： 博主的 Gridea 安装地址为： D:/Blog_Gridea，站点源文件的保存位置为 D:/Blog_Gridea_Documents，博主并不确定应该修改哪一项，于是采用了这两者都修改的方式。这里以修改 D:/Blog_Gridea_Documents 中的文件为例，这里我们只需要修改站点源文件保存位置内的文件。博主目前使用的主题是 notes，因此打开 D~~:/Blog_Gridea_Documents/themes/notes/templates/includes/gitalk.ejs，将下述代码添加到第16行（即 new Gitalk 中）（这里要注意格式） proxy: '\u003c%= commentSetting.gitalkSetting.proxy %\u003e' 然后打开 D:/Blog_Gridea_Documents/config/setting.json，将下述代码添加到第26行（即 gitalkSetting 中）（同样注意格式） \"proxy\": \"https://netnr-proxy.cloudno.de/https://github.com/login/oauth/access_token\" ⚠️ 博主将 D:/Blog_Gridea 下的文件做了上述同样的处理，这里要注意 D:/Blog_Gridea 中的 theme 和 config 文件夹在 default_files 下。博主并不清楚是否只做一处修改就可以解决Bug。 最后，只需要在 Gridea 中点击同步，等待网站部署完成即可。以上，就是解决该 Bug 的全部操作。 2021/2/14 订正 （小问号：,接 ‘~~’ 会导致删除线不能正确出现） 2022/4/26 补充上条： 这是因为你多打了个 ~~。 ","date":"2021-02-13","objectID":"/gitalk/:0:0","tags":["Gridea","Bug","Gitalk"],"title":"记录Gitalk的一个Bug","uri":"/gitalk/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 😵在书写本文时博主几乎忘记了操作顺序，可能与实际有些许所出入（不影响操作的正确性），会在未来进行订正。 😀书接上回，我们搭建了自己的 Blog 网站，并且可以使用自动分配的域名在任意时间和设备上访问。但美中不足的是，网站的网址实在是太太太太长了，例如本博客的网站地址即为 https://coding-pages-bucket-3524618-8350701-12972-499298-1301281690.cos-website.ap-hongkong.myqcloud.com ，这明显是非常难记且不符合美学的。接下来我们使用腾讯云购买域名并设置到自己的博客上。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:0:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅰ. 在腾讯云上选择一个合适的域名并购买 在腾讯云网站上搜索并购买一个域名。在提交订单时注意将推荐产品中免费的 SSL 证书勾选上白嫖的谁不爱呢。 购买之后，按照提示进行实名认证，并等待实名认证成功。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:1:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅱ. 自定义域名设置 回到 Coding 中项目页面，进入持续部署-静态网站页面，点击建立的网页（例如博主的“泡面\u0026榨菜”） 进入页面信息，注意横栏，点击自定义域名，注意最右边，点击新建域名。并填入第一步购买的域名。填写完成后我们忽略提示，复制表格中的“CNAME 指向”信息。 前往腾讯云控制台，搜索域名注册，找到购买的域名，点击解析。 点击添加记录，主机记录输入 @，记录类型选择 CNAME，记录值粘贴刚才复制的信息，点击确认。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:2:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅲ. SSL证书的部署 回到 Coding 页面自定义域名处，点击证书状态，注意页面右方的快速上手栏，稍作休息，等待证书签发（这里博主等待了约 30 分钟），签发完成后微信会有相关通知。 签发完成后，我们选择一键部署。部署类型选择 CDN，点击确定，进入配置证书页面。选择刚购买的域名，证书来源选择腾讯云托管证书，证书列表选择刚才的证书，回源协议选择 HTTPS，点击提交。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:3:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"Ⅳ. 重新配置 Gridea 打开 Gridea 软件，点击远程，将域名更换为我们购买的域名，在 CNAME 中输入第二步中复制的“CNAME 指向”信息，点击检测远程连接，此时应当连接正常。然后点击保存，并同步，网站需稍等 5 分钟左右部署完成。 以上，就完成了给 Blog 网站设置自己的域名的全部操作，现在就可以使用新域名访问网站了。 ","date":"2021-02-13","objectID":"/hello_gridea_domain/:4:0","tags":["Gridea"],"title":"Hello Gridea! - 怎样给Blog网站设置自己的域名","uri":"/hello_gridea_domain/"},{"categories":["教程"],"content":"这篇文章来自以往的 Blog，此处仅作搬运收藏，可能不再对内容进行订正 由于介绍的非常详细，本文不再重复啰嗦，有关 Gridea 的简介请见此。 ","date":"2021-02-12","objectID":"/hello_gridea/:0:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"Ⅰ. Gridea 的安装 Gridea 的下载地址 以 Windows 系统位例，安装完成后，我们注意软件左边栏，选择远程项，并将其中的平台项改为 Coding Pages，继续以下的工作。 ","date":"2021-02-12","objectID":"/hello_gridea/:1:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"Ⅱ. 部署到 Coding Pages Gridea 提供了将博客部署到 GitHub Pages、Coding Pages 和通过 SFTP 的方式上传到自己的服务器的功能。有关使用 GitHub 的 Gridea 部署方式，官方给出了一个十分详细的教程。但是由于网络的原因，GitHub 不能成为博主的优先选择，因此本教程采用腾讯系的 Coding Pages 进行部署。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:0","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"① .创建一个 Coding 账号，并创建一个 Token。 点击 Coding 进行注册。登录至工作台主页后（****.coding.net/user），注意页面右上角自己的头像，在悬停时弹出的菜单中选择个人账户设置；注意左侧边栏，选择访问令牌，进入访问令牌页面（****.coding.net/user/account/setting/tokens）。将页面中的令牌用户名填入到 Gridea 软件令牌用户名一栏中。点击新建令牌，令牌描述以便于区分为佳，例如“Gridea Site”。选择权限勾选 project:depot，即完全的仓库控制权限。点击确定，将会生成一个新令牌，请务必将令牌复制到本地保存，因为页面关闭后令牌将无法在页面上查看。将生成的令牌填入到 Gridea 软件令牌一栏中。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:1","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"②.创建一个公开仓库，以存放构建后的网站。 回到工作台主页，注意左侧边栏，选择项目，单击新建项目，选择 DevOps 项目。这时项目名称可能将无法更改，这是 Coding 网站的引导示例项目，只需随着教程操作后重新回到工作台并新建项目即可。选择 DevOps 项目，并为自己的项目起一个好听的名字虽然并没有什么用，点击完成创建，进入项目主页（****.coding.net/p/**/）。注意左侧边栏，选择代码仓库项，并点击新建代码仓库。为自己的仓库起一个好听的名字同样也没什么用，勾选生成 README 文件，勾选公开仓库，完成创建。注意项目名所在的横栏，点击设置，注意到代码仓库名称中给出的“⚠️修改仓库名称将导致仓库的访问 URL 改变，在此之前的 URL 地址将失效。Git 仓库地址修改方法”附带了代码，其格式为： git remote set-url origin https://e.coding.net/“字段 A”/“字段 B”/“字段 C”.git 打开Gridea软件，在仓库名称中填入“字段 C”，在仓库用户名中填入“字段 A”/“字段 B”，在分支中填入 master。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:2","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"},{"categories":["教程"],"content":"③.部署静态网站。 点击左侧边栏持续部署，选择静态网站，按照提示配置腾讯云权限，完成实名认证并新建静态网站。随便给网站起一个名字，点击确定，网站将进行部署。稍等至网站部署成功，点击访问，访问的网址即为 Blog 的网址。打开 Gridea 软件，将网址复制到域名中，注意 “https://” 不要重复。此时点击软件左下角的检测远程连接，如果一切配置正确的话，会出现“远程连接成功”字样。点击保存，然后点击软件右下角的同步，就可以将网页部署到 Coding Pages 上。稍等约5分钟左右再次访问 Blog 网站即可访问成功。 以上，就完成了使用 Gridea 将博客部署到 Coding Pages 上的全部步骤。 ","date":"2021-02-12","objectID":"/hello_gridea/:2:3","tags":["Gridea"],"title":"Hello Gridea! - 如何使用Gridea和Coding搭建自己的Blog","uri":"/hello_gridea/"}]