# LC1823 - 找出游戏的获胜者


<!--more-->

> 问题链接：[找出游戏的获胜者](https://leetcode.cn/problems/find-the-winner-of-the-circular-game/)

## 思考

---

本题就描述而言并不困难，可以很轻松的想出基于模拟的做法。数字按顺序绕成一圈，明显为**单循环链表**，接下来仅仅需要按照题目描叙，指针每次向下移动一位，移动到 $k$ 的整数倍后便将指针所指节点删去，直至最后只剩一个节点，该节点即为游戏的获胜者。

对于单纯的模拟来讲，只需要实现计数和单循环链表节点的删除即可轻松拿下本题。但是我们可以注意到，维护一个单循环链表，并不断地从链表上删除元素，所消耗的时间复杂度是很高的，并且这个动作并不是无可取代的。

具体而言怎样实现呢？此处提供一个不需要维护单循环链表的思路。

对于没有插入动作的单循环链表，我们可以用数组对其进行模拟。我们可以完全可以申请一片连续的内存空间：对于单循环链表**指针的移动**而言，可以使用取余来实现。我们可以将指针设为一个整形，每次移动意味着指针值 $+1$，当指针值，或者说数组下标超出数组长度后，对指针值除以数组长度做取余运算，指针值便又回到了最初的 $0$，意味着开始指针回到链表头的位置，开始了新一轮的循环。这样便会带来一个问题，那就是我们需要额外增加一个变量来记录数过了几个小伙伴，这是因为指针值（数组下标）会发生变化，单纯将指针值的 $k$ 倍所在的节点进行删除并不能删除正确的节点。

对于单循环链表**节点的删除**而言，由于小伙伴们的取值为从 $1$ 开始的整数，我们可以将已经被淘汰的小伙伴的值设为 $-1$，来代指小伙伴已经被从链表上删除，当指针经过被淘汰的小伙伴的时候，指针值 $+1$，但数过的小伙伴的数量保持不变（也就是在**指针的移动**步骤中最后增加的变量）。这样，我们就增加两个变量，使用数组取代了时间复杂度更高的单循环链表以及其维护操作。

## 代码 

---

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        gamer = [i for i in range(1, n + 1)]	# 使用数组来代表所有参加游戏的小伙伴

        count, ptr, alive = 0, -1, n			# count 为在游戏中已经数过了多少个小伙伴，ptr 为指针（数组下标） 
											# alive 为现在剩余的小伙伴数量，每次淘汰一个小伙伴，alive - 1
        while True:
            ptr += 1						# 指针移动到下一个位置
            ptr = ptr % n					# 当指针超出数组下标后，回到原点

            if gamer[ptr] == -1:			# 如果指针当前位置的小伙伴已经被淘汰
                continue					# 不再做任何操作
            else:							# 如果未被淘汰
                if alive > 1:				# 并且场上存活的小伙伴数量 > 1 
                    count += 1				# 数过一个小伙伴
                    if count % k == 0:		# 如果已经数到了第 k 个小伙伴
                        gamer[ptr] = -1		# 将小伙伴淘汰
                        alive -= 1			# 场上存活的小伙伴数量 - 1
                else:						# 如果场上只剩余 1 名小伙伴
                    return gamer[ptr]		# 返回该名小伙伴
```

模拟代码并不难，最终结果也并不好🤣：

> 执行用时: **1256 ms**，超过了 **0%** 的 **Python3** 提交记录。
>
> 内存消耗: **14.9 MB**，超过了 **64%** 的 **Python3** 提交记录。

有点搞笑了只能说，怕不是紧贴着 TLE 通过的。

## 优化

---

当暴力效果不好的时候，我们要做的便是用数学的眼光来发掘其内在规律，减少无用功。当然，互联网时代，如此便利的条件我们更应该站在巨人的肩膀上（~~面向搜索引擎解题~~）。

闲话休叙。了解了一下之后发现，从 $0$ 开始，首尾相接，每次数 $k$ 并将其淘汰，称之为**约瑟夫环**。也就是说，本题就是原汁原味的约瑟夫环问题，仅仅是将开头给换成了 $1$。事实上，本题可以使用归纳的方式寻找出规律。

关于约瑟夫环，很有趣的一点便是，**在第一轮循环中**，只要 $k$（每次淘汰要数几个数）相同，那么无论 $n$（约瑟夫环中节点总数）为多少，第一次淘汰的位置总是一样的。当然我们这里假设 $n > k$。以图为例：

<img src="https://s2.loli.net/2022/05/05/5bds6L1kGp9wVEq.png" alt="lc1835.drawio.png"  />

假设 $k = 3$ 那么我们将要淘汰的数字为环中第 $3$ 个数，也就是 $2$。可以看到，图中两环虽然 $n$ 不相同，但是所淘汰的数是相同的。

{{<admonition type=note title="注意">}}

我们大可以一直不停的淘汰下去，但是这样解决不了任何问题。因为一直淘汰下去又会使问题回归到模拟，现在我们应当试图寻找一些**规律**。

{{</admonition>}}

这里我们先将 $n = 9$ 的环上的数进行淘汰：

<img src="https://s2.loli.net/2022/05/05/EviptoMu9AG43QU.png"  />

现在，两个约瑟夫环的 $n$  是相同的，但是很难找到规律，因为上环已经断开，而下环依旧完好，两者结构相差太多。如果我们简单的将断处续接，也就是连接 $1$ 和 $3$：

<img src="https://s2.loli.net/2022/05/05/gwOuLHcxdnpryZP.png"  />

事情似乎并没有朝着我们想要发掘的内在规律靠拢，第一次循环中要被淘汰的数错列排布，依旧让人摸不到头脑。

退回到上一步，重新考虑这个约瑟夫环的问题。是的，现在我们考虑的是一个**环**，也就是说这些数是首尾相接的。既然 $1$ 和 $3$ 相接看不出端倪，那么 $0$ 和 $8$ 相接又如何呢？

<img src="https://s2.loli.net/2022/05/05/LPDAkWrCIbj8hq4.png"  />

我们注意到，需要淘汰的数，和存活的数，竟然**排列在了一起**！并且在数组的前 $6$ 位，我们可以注意到，上排数和下排数相差为定值 $3$ ，这很容易理解，因为我们将第一轮存活的数接在了数组的尾部，共 $2$ 个数，而第 $3$ 个数，也就是 **$k$ 的倍数**被淘汰。将数组上下对齐后，上排数和下排数差值为定值，也就是 $k$。

似乎忘记了续接的两个数？无需担心，因为这个问题我们早就在模拟解法中使用余数解决了。也就是说：

- 对于前 $6$ 个数，上下数组之间的对应关系为差值 $k$，例如 $4 = 1 + k = 1 + 3$。
- 对于后 $2$ 个数，上下数组之间的对应关系为差值 $k$ 及除以 $n$ 的余数，例如 $0 = (6 + 3) \\% 9$。

也就是可以表示为：

<img src="https://s2.loli.net/2022/05/05/i1bn7PZfSgEm849.png"  />

至此，我们找到了一种上下对应的关系。换句话说：**如果我们已知** $n=8,k=3$ **时何数的去留，我们便能通过数学关系** $(x+k) \\% n$ **得知** $n=9,k=3$ **时何数的去留**。这是因为由上图可知，**去留关系应该是一一对应的**。

{{<admonition type=note title="注意">}}

我们考虑的问题为约瑟夫环，这个环是首尾相接的，对上图而言，两环的差距，仅仅在**标上的数字不相同**。而由约瑟夫环的特性我们可以知道，对于一个约瑟夫环，只要起点相同，$n$ 和 $k$ 相同，那么对应位置的数字最终存活与否肯定是相同的。现在我们通过一个数学转换找到了数字之间的对应关系。

{{</admonition>}}

当然了，你可能会注意到，**我** $2$ **怎么没了**？上环的数字 $2$ 已经为了寻找规律而被淘汰，但这不重要。因为我们知道，最后的胜者肯定不会在最开始就被淘汰！因为我们所求的是最后的胜者！现在，我们假设 $f(n,k)$ 为该条件下最后的胜者，那么我们可以知道，其肯定不会被淘汰，也就是该数一定是符合下述关系的：
$$
f(n,k) = (f(n-1,k) + k) \\% n
$$
而我们又知道，如果仅有一个数，那么无论 $k$ 为多少，最后赢家一定是它，也就是约瑟夫环最开始的那个数 $0$。数学表达式为：
$$
f(1,k)=0
$$
现在，无论 $k$ 的值是多少，我们都能在 $\mathcal{O}(n)$ 的时间复杂度下，利用递推公式求出最后的赢家！

## 约瑟夫环代码

---

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        return 1 if n == 1 else (self.findTheWinner(n - 1, k) + k - 1) % n + 1	# 递推公式
```

将多行代码优化至一行！数学，很神奇吧！

{{<admonition type=tip title="提示">}}

你可能已经注意到本题与约瑟夫环的不同，那就是约瑟夫环起始数为 $0$ 而本题起始数为 $1$。这也不难解决，只需要在输出结果后使结果 $+1$ 并在进行约瑟夫环递归计算前将其减去即可。

{{</admonition>}}

最终效果：

>执行用时: **40 ms**，超过了 **71%** 的 **Python3** 提交记录。
>
>内存消耗: **15.3 MB**，超过了 **8%** 的 **Python3** 提交记录。

## 最后优化

---

上述代码使用递归实现，递归到最后有一个堆栈返回的过程，这还可以进行优化。将递归替换为迭代，也就是将倒着求结果换成正着推，并不难实现，代码如下：

```python
class Solution:
    def findTheWinner(self, n: int, k: int) -> int:
        res = 0							# 起始条件
        for i in range(n):
            res = (res + k) % (i + 1)		# 约瑟夫环递推公式
        return res + 1					# 最终结果 + 1 因为本题数字从 1 开始
```

最后节约了 4ms 的执行时间和大量的内存：

> 执行用时: **36 ms**，超过了 **89%** 的 **Python3** 提交记录。
>
> 内存消耗: **14.8 MB**，超过了 **93%** 的 **Python3** 提交记录。

## 结尾碎碎念

---

距离上次写题解过去了好多天，并不是因为我懒，这里还是要反思一下刷题的技巧的。

最开始我是顺着题目顺序刷题，事实上很多简单题做起来确实没有什么好讲的地方，导致没有什么收获。而困难题呢，又因为难度太高，就算勉强做出来，也不至于能到达清晰的梳理好题目的程度，收获甚微。反而是中等题，常常能带来很多有益的思考。我并不是说困难题和简单题就没有不能带来这种思考，只是出现的频率较少罢了。最近在按照每日一题来做，收获还是不错了。

前几天试着做了一下全站通过率最低的 LCP60 力扣泡泡龙，做了一个半小时，总算是写了出来一个通过的结果。但是说实话诈胡成分比较高，怕是测试再复杂一些就要挂在时间上。光是做就已经绞尽脑汁，优化更是有心无力了。然后第二天又连做两道 hard，头昏脑胀，直接摸了一晚上。最后也没学到什么，只能说头铁 hard 不可取。

现在是 4:32 ，明天还得，哦，今天中午 12 点还得开会，得赶紧睡了。写题解还是很耗时间的，3 千字大概写了 130 分钟，估计回家备考就很难写这种长篇题解了。

这篇文章题解绘图用的是 Draw.io 这款软件，还挺好用的。

不知道为啥公式内百分号不能正常显示，还得再研究一下。

Update：百分号前要加双反斜杠进行转义，目前不清楚原因。

最后就是，《相合之物》这动画片真好看！


{{< music url="/music/菫.mp3" name=堇 artist=坂本真绫 cover="/images/相合之物.jpg" >}}


---

> 作者: Blathers  
> URL: https://blathers23.netlify.app/lc1823/  

