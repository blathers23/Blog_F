# LC239 - 滑动窗口的最大值


<!--more-->

> 问题链接：[LC239 - 滑动窗口的最大值](https://leetcode.cn/problems/sliding-window-maximum/)

## 思考

---

在一个长为$n$的列表中有一个长为$k$的窗口，每次查找当前窗口中所有数的最大值，然后移动到下一个窗口。由于窗口中的数无序，因此查找的时间复杂度为$\mathcal{O}(k)$，因此用直接查找的方式解决该问题时间复杂度为$\mathcal{O}(nk)$。对于一个Hard题来说，明显会超时。

那么应当如何降低时间复杂度呢？注意到每次查找中都会有$k-1$个数重复，因此我们可以维护一个容器，容器中包含从窗口最左端到窗口最右端的所有数。每次我们从容器中选出值最大的数字作为滑动窗口的输出，将窗口最右端外的一个数加入容器，最后将窗口最左端的数字从容器中排除。只要不断重复这三个操作，即可解决问题。根据第一段的描述，我们已经知道，直接搜索时，重复一次这些操作的时间复杂度为$\mathcal{O}(k)$，而重复次数$n$是难以改变的。因此，为了降低时间复杂度，我们应当将这三个操作加起来的时间复杂度将至低于$\mathcal{O}(k)$。

有一个非常适合这种始终维护一个容器最大值的数据结构——大根堆。虽然大根堆建堆时间复杂度为$\mathcal{O}(klogk)$，但是在整个问题解决的周期中，只需要建堆一次。接下来考虑容器中的三个操作：从大根堆中取出最大值的时间复杂度为$\mathcal{O}(1)$，将一个新的数加入到大根堆的时间复杂度为$\mathcal{O}(logk)$，都小于$\mathcal{O}(k)$。然而，将一个特定的数从大根堆中排除是一个比较复杂的问题，但是这里我们可以采用一个以空间换取时间的手段：只需要在大根堆每一个节点中同时记录数和该数所在的位置即可。在从大根堆中取出最大值之前，需要检查以下该数所在的位置是否合法（在窗口的大小以内），若合法 ，则直接输出该数，若不合法，则需要排除该数并重新最大堆化。只要某个数不是容器中的最大值，就算不排除该数也不会对最终结果产生影响。这样该问题的时间复杂度就来到了$\mathcal{O}(nlogk)$。

## 单调队列

---

通过大根堆容器，我们已经做到了降低时间复杂度。时间复杂度可以进一步降低吗？观察大根堆我们可以注意到，在大根堆中存在一些数，这些数只会占据大根堆中的空间，也不会输出到大根堆之外，如果能排除这些数，可以进一步提高程序运行的效率。这些不会被输出的数是如何产生的呢？

考虑这样一个实际问题，输入列表为$[1, 3, -1, -3, 5, 3]$，$k=3$。在重复了多次操作后，窗口右端即将离开数字3，窗口左端即将接纳数字5，也就是我们需要将5输入到容器中：

{{<image src = "https://s2.loli.net/2023/01/02/OlAwBsFcgUQW81y.png" caption = "示意图" height = "60%" width = "60%">}}

此时，我们不去在意容器内部的细节，单单考虑那些数即使删除也不会对结果造成干扰？可以注意到一个关键的问题：将5输入到容器中之后，容器中的其它所有数都可以删除而不影响最终结果。换句话说，此时我们可以将大根堆直接抛弃然后重建，同样可以得到正确的结果。

其背后的原因是什么？我们注意到，5是大根堆里最大的数字，而且是滑动窗口中年纪最小的后辈。也就是说，5在容器中存活的时间，是要比目前容器中的其他数字都要长的。也就是说，在5的整个生命周期中，其他的数字都会因为5的存在而导致不能作为滑动窗口中的最大值输出。更一般的，我们可以发现，如果我们将某一个数$x$加入到容器中，则容器中小于$x$的所有数都不能作为滑动窗口中的最大值输出。

事实上，到目前为止我们已经发现了足够有趣的东西，而这个发现的作用已经被大根堆容器限制住了，因此我们回到抽象容器来继续讨论这个发现的作用。现在假设我们有这样一个容器，这个容器可以将容器中所有比给定的数字更小的数字删除，也可以输出容器中最大的数字，怎样实现这个容器最简单呢？是的，答案是一个单调的双端队列。让我们来考虑以下一个单调的双端队列可以达到怎样的时间复杂度。在单调队列中取出最大值的时间复杂度为$\mathcal{O}(1)$，在这样一个单调队列中添加一个数字同时删除比该数字小的所有数字的时间复杂度最差情况下为$\mathcal{O}(k)$。在这样的队列中因超出滑动窗口范围而删除一个数字又是怎样的时间复杂度呢？我们考虑在什么情况下我们需要因滑动窗口超出范围而删除数字：为简化问题，假设某个数字在其生命周期中始终作为最大值，也就是一直占据队列最左端且不会因为右侧存在比其更大的数字而被出队，则其出队一定是因为超出了滑动窗口的位置，即滑动窗口右端点位置等于双端队列左端点数的位置。出队时，只需要将双端队列左端点位置$+1$即可。事实上，一个不会因为右侧存在比其更大数字而出队的次大值在最大值于队列左端出队而成为最大值后，接下来同样会因为滑动窗口右端点位置等于双端队列左端点位置而出队。至此所有的出队可能性均已讨论，也就是说，考虑因超出滑动端口范围而出队，我们只需要检查双端队列左端点值的位置和滑动窗口右端点的位置是否相同即可。

然而，你可能已经注意到了问题所在：尽管我们通过在双端队列中引入插入数字前删除较小值的机制，大大缩短了很多不必要的时间，但向队列中添加一个数在最坏情况下时间复杂度依旧为$\mathcal{O}(k)$！这是当新插入数字比队列中所有数都大时，需要依次清空整个队列导致的。而这也意味着该容器使问题整体复杂度又回到了直接搜索的程度。事实上并非如此，直觉上来说，当某次插入一个很大的数导致多次删除操作时，同样减少了未来所有操作的复杂度。从另一个角度考虑，每一个数都至多入队和出队一次，且出队和入队都是时间复杂度$\mathcal{O}(1)$的操作，因此该方法的时间复杂度应当为为$\mathcal{O}(n)$！

## 代码

---

```C
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    if (numsSize == 0) {
        return NULL;
    }	// 列表为空直接返回NULL
	
    // 申请双端队列的空间，双端队列保存的不是列表内数的值而是列表内数的位置，便于编程。
    int* deque = malloc(sizeof(int) * numsSize);
    int headPtr = -1, tailPtr = -1;	// 双端队列的队首和队尾指针

    int i = 0, j = 0;	// 滑动窗口的左端和右端
    while (j < k) {	// 形成窗口阶段
        // 若队列不为空且新加入队列中的数字比队尾数字更小
        while (tailPtr > headPtr && nums[deque[tailPtr]] <= nums[j]) {
            tailPtr--;	// 队尾数字出队
        }
        // 数字入队。由于形成窗口阶段，因此只延伸滑动窗口左端点
        deque[++tailPtr] = j++;
    }

    *returnSize = 0;
    int* ret = malloc(sizeof(int) * (numsSize - k + 1));
    ret[(*returnSize)++] = nums[deque[headPtr + 1]];

    while (j < numsSize) {
        // 如果队头数字为滑动窗口右端点数字
        if (i == deque[headPtr + 1]) {
            headPtr++;	// 队头数字出队
        }
		
        while (tailPtr > headPtr && nums[deque[tailPtr]] <= nums[j]) {
            tailPtr--;
        }
        deque[++tailPtr] = j++;
        i++;	// 缩减滑动窗口左端点

        ret[(*returnSize)++] = nums[deque[headPtr + 1]];
    }

    return ret;
}
```

> 执行用时: **660 ms**，超过了99%的C提交记录。
>
> 内存消耗: **87.1 MB**，超过了38%的C提交记录。

---

> 作者: Blathers  
> URL: https://blathers23.netlify.app/lc239/  

